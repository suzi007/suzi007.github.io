<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏子部落阁</title>
  
  
  <link href="http://suzi007.github.io/atom.xml" rel="self"/>
  
  <link href="http://suzi007.github.io/"/>
  <updated>2025-03-29T16:33:36.389Z</updated>
  <id>http://suzi007.github.io/</id>
  
  <author>
    <name>苏子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>密评快速提分技巧——管理制度</title>
    <link href="http://suzi007.github.io/2025/03/17/%E5%AF%86%E8%AF%84%E5%BF%AB%E9%80%9F%E6%8F%90%E5%88%86%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E7%AE%A1%E7%90%86%E5%88%B6%E5%BA%A6/"/>
    <id>http://suzi007.github.io/2025/03/17/%E5%AF%86%E8%AF%84%E5%BF%AB%E9%80%9F%E6%8F%90%E5%88%86%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E7%AE%A1%E7%90%86%E5%88%B6%E5%BA%A6/</id>
    <published>2025-03-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:33:36.389Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>管理制度是密评中相对容易得分的测评内容，可以按照以下进行相关准备：</p></blockquote><h1 id="1-管理制度层面"><a href="#1-管理制度层面" class="headerlink" title="1 管理制度层面"></a>1 管理制度层面</h1><ul><li><strong>具备密码应用安全管理制度：</strong> 制定人员管理、密钥管理、建设运行、应急处置、密码软硬件及介质管理制度。</li><li><strong>密钥管理规则：</strong> <ul><li>准备密钥编制密码应用方案并通过评估。</li><li>准备密钥管理规则相关文档（根据密码应用方案建立相应密钥管理规则），密钥管理制度及策略类文档内容包含密钥全生存周期的安全性保护相关内容，且对密钥管理规则需进行评审。</li><li>信息系统重密钥按照密钥管理规则进行生存周期的管理。</li></ul></li><li><strong>建立操作规程：</strong> <ul><li>准备密钥相关管理人员或操作人员的日常操作建立操作规程。</li></ul></li><li><strong>定期修订安全管理制度：</strong> <ul><li>准备定期对密码应用安全管理制度和操作规程的合理性和适用性进行论证和审定记录。（对论证和审定后存在不足或需要改进的密钥应用安全管理制度和操作规程，提供修订记录）。</li></ul></li><li><strong>明确管理制度发布流程：</strong> <ul><li>准备应用安全管理制度和操作规程内容具有相应明确的发布流程和版本控制。</li></ul></li><li><strong>制度执行过程记录留存：</strong> <ul><li>准备密码应用操作规程执行过程中留存的相关执行记录文件。</li></ul></li></ul><blockquote><p>判定准则：<br>    测评单元准备材料都满足，该测评单元结果为符合，否则，为部分符合。<br>建议：<br>    如果测评单元准备材料有一条不满足，则该测评单元无需再准备其他材料，材料多少不影响最终得分。</p></blockquote><h1 id="2-人员管理层面"><a href="#2-人员管理层面" class="headerlink" title="2 人员管理层面"></a>2 人员管理层面</h1><ul><li><strong>了解并遵守密码相关法律法规和密码管理制度：</strong> <ul><li>系统相关人员（负责人、安全主管、密钥管理员、密码安全审计员、密码操作员）了解并遵守密码相关法律法规和密码应用安全管理制度。</li></ul></li><li><strong>建立密码应用岗位责任制度：</strong> <ul><li>准备密码应用岗位责任制度类文档，文档内容保护根据密码应用的实际情况，设置密钥管理员、密码安全审计员、密码操作人员等关键安全岗位并定义岗位职责；</li><li>对关键岗位建立多人共管机制。</li><li>禁止密码安全审计员岗位人员兼认密钥管理员、密码操作员等关键安全岗位；</li><li>禁止相关设备与系统的管理与使用账号多人共用情况。</li><li>密钥管理员、密码安全审计员、密码操作员应由本机构的内部员工担任，并应在任前对其进行背景调查（四级系统要求，提供证明文件）。</li></ul></li><li><strong>建立上岗人员培训制度：</strong> <ul><li>准备安全教育和培训计划文档，内容具有针对涉及密码的操作和管理的人员的培训计划；</li><li>准备安全教育和培训记录，内容包含有密码培训人员、密码培训内容、密码培训结果等的描述。</li></ul></li><li><strong>定期进行安全岗位人员考核：</strong> <ul><li>准备安全管理制度文档，内容包含具体的人员考核制度和惩戒措施；</li><li>准备人员考核记录，内容包含安全意识、密码操作管理技能及相关法律法规；</li><li>准备记录表单类文档，需定期对岗位人员进行考核。</li></ul></li><li><strong>建立关键岗位人员保密制度和调离制度：</strong> <ul><li>准备人员离岗的管理文档，内容包含关键岗位人员保密制度和调离制度等；</li><li>准备保密协议文档，内容包括保密范围、保密责任、违约责任、协议的有效期限和责任人的签字等内容。</li></ul></li></ul><blockquote><p>判定准则：<br>    测评单元准备材料都满足，该测评单元结果为符合，否则，为部分符合。<br>建议：<br>    如果测评单元准备材料有一条不满足，则该测评单元无需再准备其他材料，材料多少不影响最终得分。</p></blockquote><h1 id="3-建设运行"><a href="#3-建设运行" class="headerlink" title="3 建设运行"></a>3 建设运行</h1><ul><li><strong>制定密码应用方案：</strong> <ul><li>准备通过评估密码应用方案（在信息系统规划阶段）。</li></ul></li><li><strong>制定密钥安全管理策略：</strong> <ul><li>准备通过评估密码应用方案。<ul><li>已建成的系统，需要根据相关标准、密码应用需求以及前期密评的整改建议，制定密码应用改造方案可视为该系统的密码应用方案。</li></ul></li><li>准备密钥管理制度及策略类文档，内容包括确定系统设计的密钥种类、体系及生存周期环节。密钥管理制度及策略类文档需要和密码应用方案保持一致（若信息系统没有相应的密码应用方案，则核查密钥管理制度及策略类文档是否根据 GB&#x2F;T 39786-2021）。</li><li>准备相关密钥管理过程记录，记录需按照密钥管理制度及策略类文档完成密钥管理。</li></ul></li><li><strong>制定实施方案：</strong> <ul><li>准备通过评估密码应用方案；</li><li>准备密码实施方案文档，需要和密码应用方案保持一致。</li></ul></li><li><strong>投入运行前进行密码应用安全性评估：</strong> <ul><li>准备系统投入运行前的密码应用安全性评估报告（要求信息系统投入运行前组织进行密码应用安全性评估，二级及以下系统可以不要求通过评估，三级及以上系统需要通过评估）。</li></ul></li><li><strong>定期开展密码应用安全性评估及攻防对抗演习：</strong> <ul><li>准备信息系统投入运行后，定期进行的密码应用安全性评估报告及攻防对抗演戏报告。</li><li>准备整改方案（如果未通过评估，需准备整改方案和记录文档），并进行相应整改。</li></ul></li></ul><blockquote><p>判定准则：<br>    测评单元准备材料都满足，该测评单元结果为符合，否则，为部分符合。<br>建议：<br>    如果测评单元准备材料有一条不满足，则该测评单元无需再准备其他材料，材料多少不影响最终得分。</p></blockquote><h1 id="4-应急处置"><a href="#4-应急处置" class="headerlink" title="4 应急处置"></a>4 应急处置</h1><ul><li><strong>应急策略：</strong> <ul><li>准备密码应用应急策略，内容包含根据密码应用安全事件等级制定了相应的密码应用应急策略，密码应用安全事件发生时的应急处理流程及其他管理措施，并遵照执行。</li><li>提供评审记录（对应急策略进行评审）。</li><li>准备应急处置记录类文档（如发生过密码应用安全事件需提供），</li></ul></li><li><strong>事件处置（若发生过密码应用安全事件）：</strong> <ul><li>应用安全事件发生后，及时向信息系统主管部门进行报告（针对三级系统，提供证明材料）</li><li>应用安全事件发生后，及时向信息系统主管部门及归属的密码管理部门进行报告（针对四级系统，提供证明材料）。</li></ul></li><li><strong>向有关主管部门上报处置情况（若发生过密码应用安全事件）：</strong> <ul><li>准备安全事件发生情况及处置情况报告（密码应用安全事件处置完成后，向信息系统主管部门及归属的密码管理部门报告事件发生情况及处置情况）。</li></ul></li></ul><blockquote><p>判定准则：<br>    测评单元准备材料都满足，该测评单元结果为符合，否则，为部分符合。<br>建议：<br>    如果测评单元准备材料有一条不满足，则该测评单元无需再准备其他材料，材料多少不影响最终得分。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;管理制度是密评中相对容易得分的测评内容，可以按照以下进行相关准备：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-管理制度层面&quot;&gt;&lt;a href=&quot;#1-管理制度层面&quot; class=&quot;headerlink&quot; title=&quot;1 管理制度层面</summary>
      
    
    
    
    <category term="商用密码" scheme="http://suzi007.github.io/categories/%E5%95%86%E7%94%A8%E5%AF%86%E7%A0%81/"/>
    
    <category term="测评技巧" scheme="http://suzi007.github.io/categories/%E5%95%86%E7%94%A8%E5%AF%86%E7%A0%81/%E6%B5%8B%E8%AF%84%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="商用密码测评" scheme="http://suzi007.github.io/tags/%E5%95%86%E7%94%A8%E5%AF%86%E7%A0%81%E6%B5%8B%E8%AF%84/"/>
    
    <category term="测评技巧" scheme="http://suzi007.github.io/tags/%E6%B5%8B%E8%AF%84%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>IKE-scan-IPsecVPN识别工具</title>
    <link href="http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/Ike-scan/"/>
    <id>http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/Ike-scan/</id>
    <published>2025-03-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:10:32.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-工具介绍"><a href="#1-工具介绍" class="headerlink" title="1 工具介绍"></a>1 工具介绍</h1><blockquote><p>ike-scan 是一个命令行工具，用于发现和识别通过互联网的 IPsec VPN 服务器。它通过发送 IKE（Internet Key Exchange）协议的请求包来检测响应的服务器，并分析响应数据，以确定服务器的类型和配置。   </p></blockquote><h1 id="2-工具使用"><a href="#2-工具使用" class="headerlink" title="2 工具使用"></a>2 工具使用</h1><blockquote><p>1、简单扫描</p></blockquote><p>命令：&#96;ike-scan 192.168.1.10 &#x2F;&#x2F;简单扫描，查看是否有VPN服务器</p><blockquote><p>2、范围扫描</p></blockquote><p>命令：<code>ike-scan 192.168.1.1-192.168.1.254 //扫描该范围内的IP</code></p><blockquote><p>3、扫描多个目标</p></blockquote><p>命令：<code>ike-scan -f targets.txt //扫描多个目标，每行一个IP</code></p><blockquote><p>4、输出扫描结果</p></blockquote><p>命令：<code>ike-scan -f targets.txt //扫描多个目标，每行一个IP</code></p><blockquote><p>5、特殊扫描</p></blockquote><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ike-scan --config config-file.conf 192.168.1.10 //使用特定文件配置</span><br><span class="line">ike-scan --aggressive 192.168.1.10</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-工具介绍&quot;&gt;&lt;a href=&quot;#1-工具介绍&quot; class=&quot;headerlink&quot; title=&quot;1 工具介绍&quot;&gt;&lt;/a&gt;1 工具介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;ike-scan 是一个命令行工具，用于发现和识别通过互联网的 IPsec VPN</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/kaliTool/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/tags/kaliTool/"/>
    
  </entry>
  
  <entry>
    <title>Legion-网络渗透工具</title>
    <link href="http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/Legion/"/>
    <id>http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/Legion/</id>
    <published>2025-03-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:10:22.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-工具介绍"><a href="#1-工具介绍" class="headerlink" title="1 工具介绍"></a>1 工具介绍</h1><blockquote><p>Legion,是一个开源、易用、超级可扩展和半自动化的网络渗透测试工具，有助于信息系统的发现、侦察和利用。：</p></blockquote><h1 id="2-主要功能"><a href="#2-主要功能" class="headerlink" title="2 主要功能"></a>2 主要功能</h1><p>1、 使用 NMAP、whataweb、nikto、Vulners、Hydra、SMBenum、dirbuster、sslyzer 和 webslayer 等工具（大约 100 多个自动化脚本）实现自动化网络侦察和扫描。</p><p>2、 提供了易于使用的图形化操作界面，丰富的菜单选项，以及多功能操作面板，允许渗透测试人员快速寻找并利用目标主机中的漏洞。</p><p>3、 模块化功能允许用户轻松对 Legion 进行定制开发，或自动化调用自己的脚本。</p><p>4、 高度定制化扫描阶段，以躲避 IPS。</p><p>5、 自动化扫描 CPE 和 CVE。</p><p>6、 实时自动保存扫描结果和任务进展。</p><h1 id="3-工具使用"><a href="#3-工具使用" class="headerlink" title="3 工具使用"></a>3 工具使用</h1><p>![[image.gif]]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-工具介绍&quot;&gt;&lt;a href=&quot;#1-工具介绍&quot; class=&quot;headerlink&quot; title=&quot;1 工具介绍&quot;&gt;&lt;/a&gt;1 工具介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Legion,是一个开源、易用、超级可扩展和半自动化的网络渗透测试工具，有助于信息</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/kaliTool/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/tags/kaliTool/"/>
    
  </entry>
  
  <entry>
    <title>源代码审计基础</title>
    <link href="http://suzi007.github.io/2025/03/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/"/>
    <id>http://suzi007.github.io/2025/03/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2025-03-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:39:23.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><blockquote><p>源代码审计（Source Code Auditing）是指对软件源代码进行深入检查和分析，以识别其中潜在的安全漏洞、编码规范问题、性能瓶颈或其他质量缺陷的过程。它是软件安全管理中的一项重要工作，目的是确保软件在发布之前能够达到预定的安全性、稳定性和质量标准。</p></blockquote><h1 id="2-代码审计测试方法"><a href="#2-代码审计测试方法" class="headerlink" title="2 代码审计测试方法"></a>2 代码审计测试方法</h1><h2 id="2-1-自上而下审计"><a href="#2-1-自上而下审计" class="headerlink" title="2.1 自上而下审计"></a>2.1 自上而下审计</h2><blockquote><p>自上而下的代码审计方法也叫做通读代码法，是指程序收到用户请求并对其进行逻辑上的处理和操作，使用户能够得到最终返回结果的整个过程的审计。</p></blockquote><h3 id="2-1-1-常用技巧"><a href="#2-1-1-常用技巧" class="headerlink" title="2.1.1 常用技巧"></a>2.1.1 常用技巧</h3><blockquote><p>一般通过从外来输入开始逐步阅读、不断深入跟踪程序代变量，直到找到可能存在安全威胁的代码或者所有的输入都被过滤或限定为安全为止。<br>技巧：<br>    1）关注函数集文件。包括 functions、common 等关键字。<br>    2）关注配置文件。已 config 开头的文件，一般包含敏感的配置信息。<br>    3）关注安全过滤文件。安全过滤文件名中通常由 filter、safe、check 等关键字。<br>    4）关注index 文件。index 文件是一个程序的入口文件，可以大致了解整个程序的架构。</p></blockquote><h3 id="2-1-2-优缺点"><a href="#2-1-2-优缺点" class="headerlink" title="2.1.2 优缺点"></a>2.1.2 优缺点</h3><blockquote><p>优点：可以更好的了解程序的架构及业务逻辑，能够挖掘更多、质量更高的逻辑漏洞。<br>缺点：花费时间大，如果程序代码质量比较大的话，审计人员读起来会比较累。</p></blockquote><h2 id="2-2-自下而上"><a href="#2-2-自下而上" class="headerlink" title="2.2 自下而上"></a>2.2 自下而上</h2><blockquote><p>自下而上的代码审计方法（使用最多的是敏感函数逆向追踪参数法）是根据敏感函数的关键字字典，从应用点回溯器接收参数，一步一步向上跟踪，直到排除嫌疑或发现安全隐患为止。</p></blockquote><h3 id="2-2-1-常用技巧"><a href="#2-2-1-常用技巧" class="headerlink" title="2.2.1 常用技巧"></a>2.2.1 常用技巧</h3><blockquote><p>常见的敏感函数包括：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql_connect()</span><br><span class="line">mysql_query()</span><br><span class="line">update()</span><br><span class="line">insert()</span><br><span class="line">delete()</span><br><span class="line">include()</span><br><span class="line">include_once()</span><br><span class="line">require()</span><br><span class="line">require_once()</span><br><span class="line">move_uploaded_file()</span><br><span class="line">unlink()</span><br></pre></td></tr></table></figure><h3 id="2-2-2-优缺点"><a href="#2-2-2-优缺点" class="headerlink" title="2.2.2 优缺点"></a>2.2.2 优缺点</h3><blockquote><p>优点：可以快速挖掘想要的漏洞，具有可定向挖掘、高效、高质量等优点。<br>缺点：审计不全面，可能存在遗漏。</p></blockquote><h2 id="2-3-利用功能点定向审计"><a href="#2-3-利用功能点定向审计" class="headerlink" title="2.3 利用功能点定向审计"></a>2.3 利用功能点定向审计</h2><blockquote><p>利用功能点定向审计方法通过了解软件的功能点，根据经验及漏洞共享网站的统计，识别出现安全问题最高的模块，通过对这些模块的定向审计查找可能存在的安全隐患。</p></blockquote><h3 id="2-3-1-常用技巧"><a href="#2-3-1-常用技巧" class="headerlink" title="2.3.1 常用技巧"></a>2.3.1 常用技巧</h3><blockquote><p>高风险功能点：<br>    1）文件上传；<br>    2）文件管理；<br>    3）登录认证；<br>    4）找回密码；</p></blockquote><h3 id="2-3-2-优缺点"><a href="#2-3-2-优缺点" class="headerlink" title="2.3.2 优缺点"></a>2.3.2 优缺点</h3><blockquote><p>优点：可以快速挖掘想要的漏洞，具有可定向挖掘、高效、高质量等优点。<br>缺点：审计不全面，可能存在遗漏，需要审计人员对功能点上的漏洞积累大量的经验，否则可能存在遗漏，还需要了解整个程序的架构设计和运行流程。</p></blockquote><h2 id="2-4-优先审计框架安全"><a href="#2-4-优先审计框架安全" class="headerlink" title="2.4 优先审计框架安全"></a>2.4 优先审计框架安全</h2><blockquote><p>如果待审计的应用或软件使用了内部开发的或第三方的框架或代码库，则优先对应用程序核心代码框架进行审计。</p></blockquote><blockquote><p>优点：可以快速挖掘想要的漏洞，具有可定向挖掘、高效、高质量等优点。<br>缺点：审计不全面，可能存在遗漏，需要审计人员了解框架中数据获取、数据传输、数据过滤、数据输出、文件上传、敏感操作调用和数据库操作等的运行原理。</p></blockquote><h2 id="2-5-逻辑覆盖法"><a href="#2-5-逻辑覆盖法" class="headerlink" title="2.5 逻辑覆盖法"></a>2.5 逻辑覆盖法</h2><blockquote><p>逻辑覆盖法通过对程序逻辑结构的遍历实现对程序的覆盖。包括语句覆盖、判定覆盖、条件覆盖、判定——条件覆盖、条件组合覆盖和路径覆盖。</p></blockquote><blockquote><p>优点：可以发现人工不太容易发现的逻辑漏洞。<br>缺点：需要设计大量的语句覆盖、判定覆盖、条件覆盖、判定——条件覆盖、条件组合覆盖和路径覆盖测试用例，周期长。</p></blockquote><h1 id="3-代码审计技术"><a href="#3-代码审计技术" class="headerlink" title="3 代码审计技术"></a>3 代码审计技术</h1><h2 id="3-1-词法分析技术"><a href="#3-1-词法分析技术" class="headerlink" title="3.1 词法分析技术"></a>3.1 词法分析技术</h2><ul><li><strong>定义</strong>：进行词法分析的程序或者函数被称为词法分析器（Lexical analyzer，简称Lexer），也称作扫描器（Scanner）。</li><li><strong>功能</strong>：词法分析器从左至右地对源程序进行扫描，按照语言的词法规则识别各类单词，并产生相应单词的属性字（Token）。这些Token是后续语法分析、语义分析等阶段的基础。</li></ul><h3 id="3-1-1-词法分析的过程"><a href="#3-1-1-词法分析的过程" class="headerlink" title="3.1.1 词法分析的过程"></a>3.1.1 词法分析的过程</h3><ol><li><strong>输入</strong>：接收字符串形式的源程序。</li><li><strong>扫描</strong>：对源程序进行逐字符扫描，根据语言的词法规则识别单词。</li><li><strong>分类</strong>：对识别出的单词进行分类，并生成相应的Token。</li><li><strong>输出</strong>：输出Token序列，供后续的语法分析器使用。</li></ol><h3 id="3-1-2-词法分析的技术方法"><a href="#3-1-2-词法分析的技术方法" class="headerlink" title="3.1.2 词法分析的技术方法"></a>3.1.2 词法分析的技术方法</h3><p>词法分析技术方法大体上可以分为以下几类：</p><p><strong>基于规则的方法</strong>：</p><ul><li><p>这种方法通过构建语言学知识规则库进行词法分析，如各种专家系统。</p></li><li><p>规则库包含了语言的词法规则，词法分析器根据这些规则来识别单词。</p></li><li><p><strong>基于统计的方法</strong>：</p></li><li><p>这种方法通过对大规模语料库的机器学习，利用数学统计模型进行词法分析。</p></li><li><p>常用的统计模型包括隐马尔科夫模型（HMM）、N 元语法模型、信道-噪声模型、最大熵模型、支持向量机（SVM）模型、条件随机场（CRF）模型等。</p></li><li><p>统计方法能够自动从数据中学习词法规则，具有较高的灵活性和适应性。</p></li></ul><p><strong>规则与统计结合的方法</strong>：</p><ul><li>在实际应用系统中，往往采用统计与规则等多种方法相结合的方式进行词法分析。</li><li>以规则为主的系统中会采用统计方法来训练规则模型，提高规则的准确性和覆盖率。</li><li>以统计为主的模型中会采用一定的规则来消除歧义、识别未登录词等。</li></ul><h2 id="3-2-语法分析技术"><a href="#3-2-语法分析技术" class="headerlink" title="3.2 语法分析技术"></a>3.2 语法分析技术</h2><blockquote><p>1.自顶向下语法分析</p></blockquote><ul><li>自顶向下语法分析也称作面向目标的分析，从文法的开始符号出发，尝试推导出与输入的单词串完全匹配的句子。若输入的单词串是符合给定文法的句子，就一定能推导出来，否则必然出错。自顶向下语法分析方法可进一步细分为确定性分析方法和不确定性分析方法。</li><li>自顶向下的确定性分析方法需要对文法进行一定的限制。该方法简单、直观，便于手工构造或者自动生成语法分析器，是目前常用的语法分析方法之一。</li><li>自顶向下的不确定性分析方法是带回溯的分析方法，本质上是一种穷举试探方法效率低、代价高，因此很少使用。</li></ul><blockquote><p>2.自底向上语法分析</p></blockquote><ul><li>自底向上语法分析也称作移近一归约分析。简单地说，它的基本思想是对输入的符号串从左到右进行扫描，并将输入的符号逐个移入一个栈中，边移入边分析，一旦栈顶的符号串形成某个句型的句柄或可归约串(该句柄或可归约串对应于某生成式的右部),就用该生成式的左部非结尾符代替相应的右部文法符号串，这称为一步归约。重复这一过程，直至归约到栈中的只剩下文法的开始符号，即确认输入的符号串是符合文法的句子。</li><li>目前主流的自底向上语法分析器都基于 LR(k)语法分析的概念。其中，“”表示对输人进行从左到右的扫描，“R”表示反向构造一个最右推导序列，“k”表示在作出语法分析决定时向前看 k 个输入的符号。</li></ul><h2 id="3-3-抽象语法树语义分析技术"><a href="#3-3-抽象语法树语义分析技术" class="headerlink" title="3.3 抽象语法树语义分析技术"></a>3.3 抽象语法树语义分析技术</h2><blockquote><p>抽象语法树是基于抽象语法结构将源代码转换为树形结构的一种表示方式，是由编译器经过语义分析后插人语义信息生成的。它描述了从文法结构推导编程语言中的语甸的过程。抽象语法树内部的常见节点类型有二元表达式、声明、函数定义、变量定义指针引用、i 语句、函数调用、复合语句、宏的使用、跨文件调用等，每种类型的节点包含具体的信息，如定义变量时包含变量名、变量类型、变量起始和终止位置、初始化过程、初始化方式(函数、常量、表达式等)。<br>抽象语法树包含源代码执行逻辑的全部信息。通过抽象语法树，不仅能获取语法信息，还能获取语法树的语义信息(如私有变量访问出错)和大量用于分析源代码静态结构的信息。根据静态代码检测过程中常用的信息的特点，可以将源代码静态结构信息大致分为四类，分别是上下文信息、程序结构信息、控制流信息、数据流信息。把握不同类型信息差异性及每种信息对静态检测的影响是静态分析的关键。编译器通过遍历语法树，可以实现代码有效性检验，同时生成一些中间单元，为编译链接做准备<br>在通常情况下，抽象语法树是由语法分析工具生成的。ANTLR 就是一种常见的语法分析工具。</p></blockquote><h2 id="3-4-控制流分析"><a href="#3-4-控制流分析" class="headerlink" title="3.4 控制流分析"></a>3.4 控制流分析</h2><blockquote><p>控制流分析是一种用于分析程序控制流结构的静态分析技术，目的在于生成程序的控制流图。根据程序的特点，控制流分析可以分为两大类，即过程内的控制流分析和过程间的控制流分析。<br>过程内的控制流分析可以简单理解为对一个函数内部的程序执行流程的分析<br>过程间的控制流分析一般情况下是指对函数间调用关系的分析，它是基于过程内的控制流分析的，主要有以下两种方法，</p></blockquote><h2 id="3-5-数据流分析"><a href="#3-5-数据流分析" class="headerlink" title="3.5 数据流分析"></a>3.5 数据流分析</h2><blockquote><p>程序执行时，数据信息是沿着控制路径流动的。数据流分析的基础是控制流图。通常需要遍历源代码生成的控制流图，从中收集某些数据信息，如变量值产生的位置、使用情况等。程序的控制流图用于确定对变量的一次赋值可能传播到程序的哪些部分。<br>数据流分析技术的主要目的是解决数据的赋值问题，检测数据的赋值与使用是否存在不合理现象。在编译时，可以根据程序的上下文信息，对变量或表达式在不同位置运行时的不同取值进行预测，从而帮助开发人员检测代码中潜在的安全隐患。</p></blockquote><h2 id="3-6-规则检查分析"><a href="#3-6-规则检查分析" class="headerlink" title="3.6 规则检查分析"></a>3.6 规则检查分析</h2><h1 id="4-代码审计规范"><a href="#4-代码审计规范" class="headerlink" title="4 代码审计规范"></a>4 代码审计规范</h1><h2 id="4-1-代码审计的时机"><a href="#4-1-代码审计的时机" class="headerlink" title="4.1 代码审计的时机"></a>4.1 代码审计的时机</h2><blockquote><p>根据代码审计的时机，分为内部审计和外部审计。<br>内部审计通常由机构内部的软件质量保证人员开展，倾向于发现及预防安全问题的发生，在软件开发生命周期的不同阶段进行。<br>外部审计是由第三方机构开展的，通常在代码编写完成后、系统集成测试之前进行。</p></blockquote><h2 id="4-2-代码审计方法"><a href="#4-2-代码审计方法" class="headerlink" title="4.2 代码审计方法"></a>4.2 代码审计方法</h2><blockquote><p>考虑到代码审计的复杂性，通常建议采用工具和人工审计相结合的方式，将源代码审计安全弱点形成审计检查列表，根据此表对照源代码逐一进行检查。<br>注意：由于不同的专业工具采用不同的技术，导致审计结果不一致或产生误报问题，建议采用不同的工具交叉审计。</p></blockquote><h2 id="4-3-代码审计的流程"><a href="#4-3-代码审计的流程" class="headerlink" title="4.3 代码审计的流程"></a>4.3 代码审计的流程</h2><h3 id="4-3-1-审计准备"><a href="#4-3-1-审计准备" class="headerlink" title="4.3.1 审计准备"></a>4.3.1 审计准备</h3><ul><li>明确审计目的，审计代码范围等</li><li>签署保密协议，明确各自的权利和义务</li><li>背景调研，了解源代码的应用场景、目标客户、遵循的相关标准</li><li>熟悉代码，了解程序的开发语言和功能模块</li><li>定制检查列表</li></ul><h3 id="4-3-2-审计实施"><a href="#4-3-2-审计实施" class="headerlink" title="4.3.2 审计实施"></a>4.3.2 审计实施</h3><p><strong>1. 审计入场</strong></p><p>审计入场是源代码安全审计的首个步骤，主要包括审计团队的组织、审计范围的明确以及相关沟通的安排。</p><ul><li><strong>确定审计目标和范围</strong>：明确审计的目标，是对整个系统代码进行安全审计，还是仅对某个特定模块、某些功能进行审查。审计范围还包括技术栈、开发语言、工具链等。</li><li><strong>审计团队的组成</strong>：组建审计团队，由具备丰富安全审计经验的成员组成，可能包括安全专家、开发人员、测试人员等。</li><li><strong>沟通与协调</strong>：与开发团队进行前期沟通，明确审计的流程、要求以及时间表。同时，获得审计所需的访问权限、环境配置以及开发文档等。</li></ul><p><strong>2.信息收集</strong></p><p>信息收集是对源代码进行全面审查的基础，涉及到对项目背景、代码库、架构设计等的了解。</p><ul><li><strong>了解项目背景与需求</strong>：审计人员需要了解该项目的功能需求、业务流程以及项目中所使用的技术栈和开发框架，明确审计的重点。</li><li><strong>访问权限管理</strong>：确保审计团队能够访问完整的源代码库、相关配置文件及其版本控制系统（如Git仓库）。审计人员应获得代码的最新版本以及与代码相关的文档和设计方案。</li><li><strong>代码库分析</strong>：分析代码的整体结构，明确重要的模块、第三方依赖和接口等。</li><li><strong>风险评估与标记</strong>：通过与开发团队的沟通，了解系统的关键部分和高风险区域，以便集中审查资源和精力。</li></ul><p><strong>3. 代码安全缺陷检测</strong></p><p>这是审计的核心部分，旨在识别代码中的潜在安全问题。该环节包括自动化工具检测和人工分析两部分。</p><ul><li><strong>静态代码分析</strong>：使用静态分析工具（如SonarQube、Checkmarx等）对源代码进行初步扫描，识别出常见的漏洞（如SQL注入、XSS、缓冲区溢出等）。</li><li><strong>手动审计</strong>：静态分析只能识别出一部分漏洞，因此需要审计人员手动检查代码。人工检查有助于发现逻辑漏洞、业务逻辑缺陷等自动化工具难以识别的隐患。</li><li><strong>依赖项分析</strong>：检查项目中使用的第三方库或框架，识别是否存在已知漏洞或安全问题。使用工具（如OWASP Dependency-Check）来跟踪依赖项的安全性。</li><li><strong>常见漏洞的检测</strong>：<ul><li><strong>输入验证</strong>：检查输入是否经过充分验证和清洗。</li><li><strong>身份验证与授权</strong>：确保所有的身份验证和授权机制得当，避免绕过。</li><li><strong>数据保护</strong>：确保敏感数据得到加密保护，如密码、密钥等。</li><li><strong>错误处理</strong>：检查错误和异常处理是否适当，避免泄漏敏感信息。</li></ul></li></ul><p><strong>4. 特殊情形审查</strong></p><p>在某些特殊情况下，需要进行深入的代码审查。特殊情形审查通常针对高风险区域、复杂业务逻辑或特殊技术栈的审计。</p><ul><li><strong>高风险模块审查</strong>：针对安全性要求较高的模块进行重点审查，如支付系统、身份验证模块等。</li><li><strong>复杂业务逻辑审查</strong>：某些复杂的业务逻辑可能容易产生漏洞，尤其是在处理金融交易或关键数据时。</li><li><strong>异构技术栈审查</strong>：对于使用混合技术栈（例如前端与后端使用不同框架或语言）的项目，需要特别审查技术间的接口和数据交换部分。</li><li><strong>前后端协同审查</strong>：在现代Web应用中，前后端代码常常紧密协作，需要确保前后端交互中的安全性，避免XSS、CSRF等攻击。</li></ul><p><strong>5. 审计报告</strong></p><p>审计报告是源代码安全审计的最终交付成果，报告需清晰、详细地记录审计过程、发现的漏洞、风险等级及相应的修复建议。</p><ul><li><strong>报告结构</strong>：<ul><li><strong>引言与背景</strong>：包括审计目标、审计范围、时间框架及审计方法。</li><li><strong>漏洞汇总</strong>：对发现的漏洞进行分类和汇总，按照严重性级别（高、中、低）排列。</li><li><strong>每个漏洞的描述</strong>：每个漏洞的详细描述，包括漏洞的发生原因、影响范围和风险。</li><li><strong>修复建议</strong>：针对每个漏洞，提供详细的修复建议，包括具体的代码修改、配置调整或其他措施。</li><li><strong>合规性检查</strong>：如果适用，检查项目是否符合相关的安全标准和法规（如GDPR、PCI-DSS等）。</li><li><strong>总结与改进建议</strong>：对审计过程和项目的安全性做出总结，并提出改进建议。</li></ul></li></ul><p><strong>6. 改进跟踪</strong></p><p>安全审计不仅是发现问题，还需要确保问题得到有效修复并进行跟踪。</p><ul><li><strong>修复跟踪</strong>：对于每个发现的漏洞，需要与开发团队协调，确保及时修复。审计团队可以帮助开发人员理解漏洞的根本原因，并提供解决方案。</li><li><strong>验证与复审</strong>：在漏洞修复后，审计团队需对修复工作进行验证，确保问题被彻底解决并且没有引入新的问题。复审可以通过回归测试和重新审计代码进行。</li><li><strong>持续改进</strong>：源代码安全审计应该是一个持续的过程。在修复漏洞的基础上，团队应定期进行新的安全审计，并结合最新的安全威胁和攻击手段进行调整。</li></ul><h2 id="4-4-审计报告"><a href="#4-4-审计报告" class="headerlink" title="4.4 审计报告"></a>4.4 审计报告</h2><p>1、审计总体信息</p><ul><li>审计日期</li><li>审计团队成员信息</li><li>审计依据</li><li>审计原则</li><li>源代码的信息，包括但不限于被审计源代码的版本号、源代码语言类型、源代码总行数等<br>2、审计流程与内容</li><li>对审计流程、采用的审计方法和审计内容进行详细描述。<br>3、发现的安全缺陷汇总</li><li>在当前版本代码中发现的异常情况汇总</li><li>可能造成的严重后果<br>4、发现的安全缺陷分析</li><li>高风险安全缺陷分析</li><li>中风险安全缺陷分析</li><li>低风险安全缺陷分析<br>5、审计总结</li><li>审计结果汇总</li><li>残余缺陷分析</li><li>安全缺陷改进建议</li></ul><h1 id="5-代码审计工具"><a href="#5-代码审计工具" class="headerlink" title="5 代码审计工具"></a>5 代码审计工具</h1><h2 id="5-1-cppcheck"><a href="#5-1-cppcheck" class="headerlink" title="5.1 cppcheck"></a>5.1 cppcheck</h2><p><strong>Cppcheck</strong> 是一个开源的静态分析工具，专门用于检查 C 和 C++ 代码中的潜在缺陷、错误和不规范的代码。它可以帮助开发者在编写代码的过程中及早发现问题，从而提升代码质量，减少运行时错误。</p><h3 id="5-1-1-优点："><a href="#5-1-1-优点：" class="headerlink" title="5.1.1 优点："></a>5.1.1 <strong>优点：</strong></h3><ol><li><p><strong>开源且免费</strong> Cppcheck 是一个完全免费的开源工具，没有使用许可证的费用，开发人员可以自由使用和修改。</p></li><li><p><strong>支持 C 和 C++</strong> Cppcheck 专注于 C 和 C++ 代码的静态分析，能够处理这两种语言中常见的编程问题，包括内存泄漏、空指针解引用、数组越界等。</p></li><li><p><strong>易于集成</strong> Cppcheck 可以与多种集成开发环境（IDE）结合使用，如 Visual Studio、Eclipse 等。此外，它也能与持续集成工具（如 Jenkins）结合，进行自动化的代码审计。</p></li><li><p><strong>详细的错误报告</strong> Cppcheck 能生成清晰、详细的错误报告，列出代码中潜在问题的类型、位置及其可能的影响。报告格式可以自定义，便于开发者理解和处理。</p></li><li><p><strong>支持多种分析模式</strong> Cppcheck 提供了不同的分析模式，包括：普通检查、细致检查、深度检查等。开发者可以根据需要选择不同的深度和细致度，平衡分析的全面性和性能。</p></li><li><p><strong>高效的错误检测</strong> Cppcheck 能检测多种常见的编程错误和潜在缺陷，如内存泄漏、资源泄漏、指针错误、类型不匹配、未初始化变量等。它通过静态分析代码结构，及时发现隐藏的潜在问题。</p></li><li><p><strong>扩展性和插件支持</strong> Cppcheck 具有良好的扩展性，支持自定义规则和插件，适应不同项目的需求。开发者可以为特定项目编写定制的检查规则。</p></li><li><p><strong>高效的性能</strong> 与其他一些静态分析工具相比，Cppcheck 通常较为轻量，适用于快速扫描大规模的代码库。它的性能较为高效，即使在大型项目中运行时，通常也能保持较低的开销。</p></li></ol><h3 id="5-1-2-缺点："><a href="#5-1-2-缺点：" class="headerlink" title="5.1.2 缺点："></a>5.1.2 <strong>缺点：</strong></h3><ol><li><p><strong>仅支持 C 和 C++</strong> Cppcheck 专注于 C 和 C++，对于其他编程语言（如 Java、Python 等）并不适用。在多语言项目中，开发者可能需要使用其他工具来覆盖所有语言的代码质量检查。</p></li><li><p><strong>较为简单的检查规则</strong> 尽管 Cppcheck 能检测许多常见的错误和潜在问题，但与一些更为强大的商业静态分析工具（如 Coverity、SonarQube）相比，其检查规则可能较为基础，不能深入到代码的细节层面，可能会错过一些高级的代码质量问题。</p></li><li><p><strong>报告质量和配置复杂</strong> 对于某些开发者而言，Cppcheck 生成的报告可能有时不够详细或准确，特别是对于更复杂的项目。此外，配置 Cppcheck 和定制规则时，开发者可能需要花费一定的时间来进行调试和设置。</p></li><li><p><strong>对现代 C++ 标准支持有限</strong> 尽管 Cppcheck 不断更新，但对一些新版本 C++（如 C++11、C++14、C++17、C++20）的支持可能不如其他更先进的工具。某些新的 C++ 语言特性可能未被充分支持或需要额外的配置。</p></li><li><p><strong>缺乏对运行时错误的检测</strong> 由于 Cppcheck 是静态分析工具，它无法捕获运行时错误或动态行为，比如并发问题、复杂的内存管理问题等。它只能依赖代码的静态特征进行检查，无法发现实际执行时发生的问题。</p></li></ol><h2 id="5-2-RIPS"><a href="#5-2-RIPS" class="headerlink" title="5.2 RIPS"></a>5.2 RIPS</h2><p>RIPS（Real-time Integrated Prevention System）是一个用于源代码静态分析的安全审计工具，主要用于检测PHP应用中的安全漏洞。RIPS通过自动化分析源代码来识别潜在的漏洞，并提供详细的报告。</p><h3 id="5-2-1-优点："><a href="#5-2-1-优点：" class="headerlink" title="5.2.1 优点："></a>5.2.1 <strong>优点：</strong></h3><ol><li><p><strong>自动化扫描</strong> RIPS能够自动化扫描代码，减少了人工审计的时间和工作量。它可以高效地分析整个项目或特定模块中的代码，快速发现潜在漏洞。</p></li><li><p><strong>专注于PHP代码</strong> RIPS是针对PHP应用开发的，特别适合PHP环境下的安全审计。它能够针对PHP常见的漏洞，如SQL注入、XSS、文件包含等，提供精准的检测和报告。</p></li><li><p><strong>详细的漏洞报告</strong> RIPS能够生成详细的报告，其中包含每个漏洞的位置、漏洞的描述以及如何修复的建议。这些报告可以帮助开发人员快速理解漏洞的风险并进行修复。</p></li><li><p><strong>支持多种安全漏洞检测</strong> RIPS支持检测多种常见的Web应用漏洞，包括：    </p><ul><li>SQL注入</li><li>跨站脚本攻击（XSS）</li><li>文件包含漏洞</li><li>不安全的反序列化</li><li>CSRF（跨站请求伪造）等</li></ul></li><li><p><strong>可视化漏洞地图</strong> RIPS提供了可视化的漏洞地图，帮助用户更清晰地了解项目中的安全状态，尤其是对于大型项目，能够帮助开发者更好地定位和理解代码中的安全问题。</p></li><li><p><strong>集成开发环境支持</strong> RIPS可以集成到CI&#x2F;CD工具链中，进行持续的安全检测，确保在软件开发生命周期的每个阶段都能及时发现和修复安全问题。</p></li></ol><h3 id="5-2-2-缺点："><a href="#5-2-2-缺点：" class="headerlink" title="5.2.2 缺点："></a>5.2.2 <strong>缺点：</strong></h3><ol><li><p><strong>仅支持PHP语言</strong> RIPS的主要弱点是它只支持PHP代码审计。如果你的项目使用的是其他编程语言，如Java、Python、Ruby等，那么RIPS就不适用了。在多语言环境下，无法满足跨语言的安全审计需求。</p></li><li><p><strong>无法捕获运行时漏洞</strong> RIPS主要依赖静态分析，而静态分析无法发现运行时产生的漏洞。例如，动态交互、后端数据库的实际状态或某些特定的外部依赖项等，RIPS无法在运行时的环境中检测到相关问题。</p></li><li><p><strong>目前已暂停更新</strong></p></li></ol><h2 id="5-3-FindBugs"><a href="#5-3-FindBugs" class="headerlink" title="5.3 FindBugs"></a>5.3 FindBugs</h2><p>FindBugs 是一款广泛使用的开源静态代码分析工具，主要用于检测 Java 代码中的潜在缺陷和安全漏洞。它通过分析 Java 字节码来发现潜在的问题，并提供报告以供开发人员改进代码质量。以下是 FindBugs 的优缺点：</p><h3 id="5-3-1-优点："><a href="#5-3-1-优点：" class="headerlink" title="5.3.1 优点："></a>5.3.1 <strong>优点：</strong></h3><ol><li><p><strong>开源且免费</strong> FindBugs 是一个开源工具，可以免费使用并且没有任何许可费用。它为开发者和团队提供了一个无成本的代码质量分析解决方案。</p></li><li><p><strong>集成开发环境（IDE）支持</strong> FindBugs 能够集成到多种 IDE 中，如 Eclipse、IntelliJ IDEA 等，提供实时的静态分析功能。这使得开发人员能够在编码过程中即时发现潜在的错误，及时修复，从而提高开发效率。</p></li><li><p><strong>检测多种缺陷</strong> FindBugs 能够检测多种常见的编码缺陷和潜在的运行时错误，包括：</p><ul><li>空指针异常（NullPointerException）</li><li>潜在的并发问题</li><li>不必要的对象创建</li><li>不符合规范的编码模式</li><li>资源泄漏等</li></ul></li><li><p><strong>定期更新与维护</strong> 作为一个开源项目，FindBugs 定期获得社区贡献和更新，这意味着它持续适应 Java 语言的变化，并加入对新技术和最佳实践的支持。</p></li><li><p><strong>灵活的插件支持</strong> FindBugs 提供了多个插件，可以扩展工具的功能，并与其他工具（如 Jenkins）集成，便于在持续集成（CI）和持续部署（CD）中进行代码质量检查。</p></li><li><p><strong>详细的错误报告</strong> FindBugs 提供详细的报告，描述每个潜在缺陷的类型、位置以及修复建议。这个功能对于开发人员和项目经理来说，能够迅速定位问题并采取措施进行修复。</p></li><li><p><strong>易于使用</strong> FindBugs 具有简单易懂的用户界面，开发者可以轻松使用其核心功能。即便没有深入了解静态代码分析原理的开发人员，也能使用这个工具来发现代码中的潜在问题。</p></li></ol><h3 id="5-3-2-缺点："><a href="#5-3-2-缺点：" class="headerlink" title="5.3.2 缺点："></a>5.3.2 <strong>缺点：</strong></h3><ol><li><p><strong>只支持 Java 代码</strong> FindBugs 是专门针对 Java 代码的静态分析工具，对于使用其他编程语言（如 Python、C++ 等）的项目不适用。在多语言环境中，FindBugs 的适用性有限。</p></li><li><p><strong>无法检测运行时错误</strong> 作为静态分析工具，FindBugs 只能检测代码在编译时可见的潜在缺陷，无法发现动态行为（如运行时的异常或错误）。对于一些只在特定条件下才会出现的问题，FindBugs 可能无法检测到。</p></li><li><p><strong>有限的支持和社区</strong> 尽管 FindBugs 有一个开源社区，但与其他流行工具相比，它的支持和社区活动相对较少。许多新特性和错误修复可能会迟迟不能得到解决或更新，尤其是在更复杂的环境中。    </p></li><li><p><strong>缺乏全面的安全分析</strong> FindBugs 的焦点主要是常见的编码问题和运行时错误的检测，而对 Web 安全漏洞（如 SQL 注入、XSS 等）的检测较为薄弱。如果需要全面的安全分析，FindBugs 可能需要与其他工具（如 OWASP Dependency-Check 或 SonarQube）一起使用。</p></li></ol><h2 id="5-4-Fortify-SCA"><a href="#5-4-Fortify-SCA" class="headerlink" title="5.4 Fortify SCA"></a>5.4 Fortify SCA</h2><p><strong>Fortify Static Code Analyzer (SCA)</strong> 是由 <strong>Micro Focus</strong> 提供的一个静态应用安全测试工具，旨在通过静态分析源代码，帮助开发人员和安全团队识别和修复应用程序中的安全漏洞。Fortify SCA 的代码审计功能可以用于检测各类安全问题，尤其是在大型企业应用中的应用程序中。</p><h3 id="5-4-1-优点："><a href="#5-4-1-优点：" class="headerlink" title="5.4.1 优点："></a>5.4.1 <strong>优点：</strong></h3><ol><li><p><strong>深度分析与全面的漏洞检测</strong> Fortify SCA 提供了深入的静态代码分析，支持多种编程语言（如 Java、C&#x2F;C++、C#、Python、JavaScript 等），能够检测应用程序中各种类型的安全漏洞，包括 SQL 注入、跨站脚本攻击 (XSS)、不安全的加密方法、缓冲区溢出等。</p></li><li><p><strong>集成支持</strong> Fortify SCA 可以与许多开发工具和集成开发环境（IDE）结合使用，如 Eclipse、Visual Studio 和 IntelliJ IDEA，甚至可以与 CI&#x2F;CD 管道（如 Jenkins）集成，实现自动化的代码审计和漏洞扫描，帮助团队更早地发现和修复安全问题。</p></li><li><p><strong>广泛的规则库与更新</strong> Fortify SCA 提供了广泛的漏洞检测规则库，覆盖了大量常见的安全漏洞。规则库定期更新，以适应新的漏洞和安全威胁，确保扫描结果的准确性和时效性。</p></li><li><p><strong>全面的报告与详细的漏洞描述</strong> Fortify SCA 提供清晰、详细的漏洞报告，描述每个漏洞的类型、位置以及潜在的安全风险。它还提供了修复建议和参考文档，帮助开发人员理解漏洞及其修复方式，从而降低修复难度。</p></li><li><p><strong>支持多种语言与平台</strong> Fortify SCA 支持多个编程语言、框架和平台，并能针对这些语言的特定特性进行分析。例如，它可以分析 Java Web 应用程序的安全性，或分析 C&#x2F;C++ 代码中的缓冲区溢出问题。它的多语言支持使得它可以用于多种类型的开发项目。</p></li><li><p><strong>集成到开发生命周期中</strong> Fortify SCA 能够无缝地集成到开发生命周期的各个阶段，从开发到测试再到生产环境，确保在开发过程中尽早发现漏洞，提升整体软件质量和安全性。</p></li><li><p><strong>高级漏洞分析与支持</strong> Fortify SCA 提供了先进的漏洞分析功能，能够深度检测更复杂的漏洞，例如逻辑漏洞、权限问题和安全配置错误。这对于大型、复杂的企业应用尤为重要。</p></li></ol><h3 id="5-4-2-缺点："><a href="#5-4-2-缺点：" class="headerlink" title="5.4.2 缺点："></a>5.4.2 <strong>缺点：</strong></h3><ol><li><p><strong>高成本</strong> Fortify SCA 是一个商业软件，许可费用较高，尤其对于中小型公司而言可能成本较为沉重。许可证的费用和相关服务（如支持和培训）可能需要较大的预算投入。    </p></li><li><p><strong>不支持动态分析</strong> Fortify SCA 专注于静态代码分析，因此它无法进行动态安全分析。某些安全问题（如运行时的逻辑漏洞、并发问题等）无法通过静态分析检测到，开发团队可能需要使用其他动态分析工具来弥补这一缺陷。</p></li><li><p><strong>依赖源代码</strong> Fortify SCA 进行的静态分析依赖于源代码，因此它可能无法检查某些经过编译或打包后的二进制代码中的漏洞。对于某些已部署的应用程序，必须获取源代码才能进行分析，限制了其应用场景。</p></li></ol><h2 id="5-5-Checkmarx-CxSuite"><a href="#5-5-Checkmarx-CxSuite" class="headerlink" title="5.5 Checkmarx CxSuite"></a>5.5 Checkmarx CxSuite</h2><p><strong>Checkmarx CxSuite</strong> 是一款领先的静态应用安全测试（SAST）工具，专为帮助开发团队在代码开发早期发现和修复安全漏洞而设计。Checkmarx CxSuite 提供一系列的工具和功能，帮助组织确保应用程序的安全性，降低潜在的安全风险。</p><h3 id="5-5-1-优点："><a href="#5-5-1-优点：" class="headerlink" title="5.5.1 优点："></a>5.5.1 <strong>优点：</strong></h3><ol><li><p><strong>强大的静态分析能力</strong> Checkmarx CxSuite 能够分析各种编程语言的源代码，包括 Java、C&#x2F;C++、C#、JavaScript、Python、PHP 等。它能够深入挖掘代码中的安全漏洞，并检测诸如 SQL 注入、跨站脚本攻击 (XSS)、跨站请求伪造 (CSRF)、缓冲区溢出等常见漏洞。</p></li><li><p><strong>集成开发环境支持</strong> Checkmarx CxSuite 可以与多种开发环境（IDE）和 CI&#x2F;CD 工具集成，如 Jenkins、Azure DevOps、GitHub、Bitbucket、Jira 等，确保在开发和测试阶段尽早发现并修复漏洞，促进 DevSecOps 的实施。</p></li><li><p><strong>可扩展性和自定义规则</strong> Checkmarx CxSuite 支持高度的可扩展性，企业可以根据自己的需求添加自定义规则来检测特定类型的漏洞。此外，工具也可以根据行业要求进行调整，确保符合企业和法律合规标准。</p></li><li><p><strong>支持动态和静态分析</strong> 除了静态代码分析外，Checkmarx CxSuite 还支持动态分析（DAST），可以帮助发现运行时的安全漏洞，提升全面的安全保障。通过结合静态分析和动态分析，能够更有效地发现漏洞并减少安全风险。</p></li><li><p><strong>深度的漏洞报告与修复建议</strong> Checkmarx CxSuite 提供详细的漏洞报告，报告不仅列出了漏洞的类型、位置，还提供了如何修复漏洞的具体建议。这帮助开发人员更快速地理解漏洞并采取合适的措施进行修复。</p></li><li><p><strong>高效的漏洞优先级排序</strong> Checkmarx CxSuite 会根据漏洞的严重性和潜在影响对其进行优先级排序，帮助开发团队聚焦于最关键的漏洞，从而提升修复效率和减少安全风险。</p></li><li><p><strong>云与本地部署灵活性</strong> Checkmarx CxSuite 支持云端和本地部署的灵活选项，可以根据企业的需求选择合适的部署方式，适应不同规模的组织。</p></li><li><p><strong>支持多个平台与语言</strong> Checkmarx CxSuite 支持多种平台和框架，包括传统的 Web 应用程序、移动应用程序、微服务架构等，适用于广泛的开发场景。</p></li></ol><h3 id="5-5-2-缺点："><a href="#5-5-2-缺点：" class="headerlink" title="5.5.2 缺点："></a>5.5.2 <strong>缺点：</strong></h3><ol><li><p><strong>较高的成本</strong> Checkmarx CxSuite 是一款商业工具，尤其对于小型企业或预算有限的团队来说，许可费用可能较为高昂。根据使用范围和功能模块，费用可能成为一个不小的负担。    </p></li><li><p><strong>可能需要其他工具配合</strong> Checkmarx CxSuite 主要专注于静态分析和动态分析，但它无法检测所有类型的漏洞，如某些逻辑漏洞、运行时并发问题等。因此，企业可能还需要配合其他安全工具进行全面的安全检测。</p></li></ol><h2 id="5-6-Coverity-Prevent"><a href="#5-6-Coverity-Prevent" class="headerlink" title="5.6 Coverity Prevent"></a>5.6 Coverity Prevent</h2><p><strong>Coverity Prevent</strong> 是由 <strong>Synopsys</strong> 公司提供的一款静态代码分析工具，专注于帮助开发团队发现并修复代码中的安全漏洞、质量问题和维护性缺陷。它能够自动分析代码并提供详细的漏洞报告，广泛应用于软件开发过程中的质量保证和安全审计。</p><h3 id="5-6-1-优点："><a href="#5-6-1-优点：" class="headerlink" title="5.6.1 优点："></a>5.6.1 <strong>优点：</strong></h3><ol><li><p><strong>高精度的漏洞检测</strong> Coverity Prevent 提供了强大的静态分析能力，能够精准地识别源代码中的潜在漏洞，包括内存泄漏、空指针引用、整数溢出、并发问题、越界访问等安全漏洞。它具有很低的误报率和漏报率，能够帮助开发人员快速发现问题并修复。</p></li><li><p><strong>支持多种编程语言和平台</strong> Coverity Prevent 支持多种流行的编程语言，包括 C&#x2F;C++、Java、C#、JavaScript、Python、Go、Swift 等。它还能够适配不同的操作系统和开发平台（如 Linux、Windows 等），为跨平台的开发团队提供一致的代码质量管理体验。</p></li><li><p><strong>深度的代码分析能力</strong> Coverity Prevent 不仅能够进行表面上的漏洞检测，还能够深入到代码的内部逻辑，识别代码中的复杂错误模式。它可以分析大量的复杂代码库，并能够识别那些可能影响软件质量的隐性问题。</p></li><li><p><strong>集成开发流程</strong> Coverity Prevent 可以与开发工具链（如 Jenkins、Git、Bitbucket、Maven 等）集成，支持持续集成和持续交付（CI&#x2F;CD）流程。它可以自动触发扫描，实时报告安全和质量问题，帮助团队在开发过程中即时发现并解决问题，从而提升软件质量。</p></li><li><p><strong>详细的报告和可操作的修复建议</strong> 生成的分析报告非常详细，包含了漏洞的严重性、具体位置、漏洞类型以及修复建议。通过这些信息，开发人员能够迅速理解问题所在，并采取针对性的修复措施。Coverity Prevent 还提供了修复优先级，帮助开发团队高效地处理最关键的安全问题。</p></li><li><p><strong>增强的代码质量管理</strong> 除了漏洞检测，Coverity Prevent 还注重代码质量，能够分析代码复杂度、可维护性等方面的问题。这对于大型项目和团队来说尤其重要，有助于长期维持高质量的代码库。</p></li><li><p><strong>强大的企业级支持</strong> Coverity Prevent 为企业级用户提供了强大的技术支持和咨询服务，确保用户能够高效地使用工具，并在遇到复杂问题时获得及时的帮助。</p></li><li><p><strong>符合行业安全标准</strong> Coverity Prevent 能够帮助企业满足各类安全合规要求，例如 OWASP Top 10、CWE&#x2F;SANS Top 25 等。它提供了一些专门的规则集，用于检测特定领域的安全问题，例如金融、医疗和航空等行业。</p></li></ol><h3 id="5-6-2-缺点："><a href="#5-6-2-缺点：" class="headerlink" title="5.6.2 缺点："></a>5.6.2 <strong>缺点：</strong></h3><ol><li><strong>高昂的价格</strong> Coverity Prevent 是一款商业化工具，价格相对较高。对于小型团队或者初创公司来说，可能会觉得负担较大。尤其是在预算有限的情况下，企业可能需要考虑是否值得投资。</li></ol><h2 id="5-7-kiwi"><a href="#5-7-kiwi" class="headerlink" title="5.7 kiwi"></a>5.7 kiwi</h2><p><strong>Kiwi</strong> 是一个开源的源代码审计工具，专为开发人员和安全专家设计，用于静态分析应用程序的源代码，以识别潜在的安全漏洞。</p><h3 id="5-7-1-优点："><a href="#5-7-1-优点：" class="headerlink" title="5.7.1 优点："></a>5.7.1 <strong>优点：</strong></h3><ol><li><p><strong>开源免费</strong> Kiwi 是一个开源工具，这意味着它对于个人开发者和小型团队来说没有许可费用，可以自由使用、修改和分发代码。这大大降低了安全审计的门槛。</p></li><li><p><strong>多语言支持</strong> Kiwi 支持多种编程语言的静态分析，包括 Java、C、C++、Python、PHP 等。这使得它能够适应不同开发环境中的安全审计需求。</p></li><li><p><strong>简洁易用</strong> Kiwi 的使用界面和命令行工具相对简洁易懂。用户无需过多的学习成本即可开始使用，尤其是对于有一定安全背景的开发人员。</p></li><li><p><strong>灵活的插件架构</strong> Kiwi 提供灵活的插件系统，可以根据需求扩展其功能。用户可以通过自定义插件来适配特定的语言、框架或项目需求，增强工具的通用性。</p></li><li><p><strong>漏洞检测能力</strong> Kiwi 能够检测常见的安全漏洞，如 SQL 注入、跨站脚本攻击 (XSS)、文件包含漏洞、缓冲区溢出等。它的漏洞检测能力对常见的 Web 应用安全问题具有较好的覆盖。</p></li><li><p><strong>持续更新</strong> 作为开源项目，Kiwi 由社区和开发者不断更新和改进，通常能较快响应新的安全漏洞和技术趋势，及时添加新的漏洞规则和分析方法。</p></li><li><p><strong>集成支持</strong> Kiwi 可以集成到 CI&#x2F;CD 流程中，帮助开发团队在持续集成的过程中进行安全审计，实现 DevSecOps，从而实现更高效的漏洞检测和修复。</p></li></ol><h3 id="5-7-2-缺点："><a href="#5-7-2-缺点：" class="headerlink" title="5.7.2 缺点："></a>5.7.2 <strong>缺点：</strong></h3><ol><li><p><strong>功能较为基础</strong> 相较于一些商业化的源代码审计工具，Kiwi 的功能较为基础，可能不支持一些高级的漏洞检测技术，如复杂的动态分析、深度的代码路径分析等。对于复杂的应用程序，Kiwi 的漏洞检测可能存在一些限制。</p></li><li><p><strong>漏洞报告和修复建议不足</strong> Kiwi 的漏洞报告较为简洁，缺乏一些深入的修复建议。开发人员需要自己通过其他渠道获取关于如何修复漏洞的具体细节，这可能会影响修复效率。</p></li></ol><h2 id="5-8-Seay"><a href="#5-8-Seay" class="headerlink" title="5.8 Seay"></a>5.8 Seay</h2><p><strong>Seay</strong> 是一款开源的静态源代码审计工具，旨在帮助开发者和安全专家发现代码中的潜在安全漏洞。以下是 <strong>Seay 源代码审计工具</strong> 的优缺点分析：</p><h3 id="5-8-1-优点："><a href="#5-8-1-优点：" class="headerlink" title="5.8.1 优点："></a>5.8.1 <strong>优点：</strong></h3><ol><li><p><strong>开源和免费</strong> Seay 是开源工具，任何人都可以免费使用、修改和分发。这使得它对个人开发者、中小型企业以及学术界都非常友好，降低了安全审计的门槛。</p></li><li><p><strong>支持多种编程语言</strong> Seay 支持多种常见编程语言的静态代码分析，包括 Java、C、C++、Python、PHP、Go 等。这使得它能够适应多种开发环境，满足跨语言应用的安全审计需求。</p></li><li><p><strong>简洁的用户界面</strong> Seay 的用户界面直观且易于操作，适合开发人员和安全分析人员使用。即便是初学者，也能在较短的时间内上手使用。</p></li><li><p><strong>强大的规则库</strong> Seay 内置了大量的漏洞检测规则，能够发现多种常见的安全漏洞，比如 SQL 注入、跨站脚本攻击 (XSS)、命令注入、路径遍历等，覆盖了许多常见的应用安全问题。</p></li><li><p><strong>集成和自动化支持</strong> Seay 支持与 CI&#x2F;CD 流程的集成，使得开发团队能够在开发和部署过程中自动进行源代码审计，帮助尽早发现和修复安全漏洞，推动 DevSecOps 的实现。</p></li><li><p><strong>扩展性强</strong> Seay 提供插件机制，用户可以根据需要扩展其功能，定制适用于特定项目或特定框架的审计规则。这让它具备了较高的灵活性，能够适应多变的开发需求。</p></li><li><p><strong>社区支持</strong> 作为一个开源项目，Seay 拥有活跃的社区，用户可以通过论坛、GitHub 等渠道寻求帮助，分享经验和报告问题。社区的反馈和贡献可以帮助工具不断完善和优化。</p></li></ol><h3 id="5-8-2-缺点："><a href="#5-8-2-缺点：" class="headerlink" title="5.8.2 缺点："></a>5.8.2 <strong>缺点：</strong></h3><ol><li><p><strong>功能相对基础</strong> 尽管 Seay 提供了基本的静态代码分析功能，但它的功能相对简洁，可能不如一些商业工具那么全面。对于更复杂或需要高级分析功能的应用程序，Seay 可能不够强大。</p></li><li><p><strong>缺乏动态分析</strong> Seay 主要侧重于静态分析，对于某些类型的漏洞（例如涉及运行时行为的漏洞），它的检测能力较为有限。相比之下，一些动态分析工具能在运行时发现更多安全问题。    </p></li><li><p><strong>安全漏洞的报告和修复建议不足</strong> Seay 的漏洞报告虽然涵盖了多个安全问题，但它的报告可能相对简洁，缺乏详细的修复建议和漏洞的上下文说明。这需要开发人员依赖其他资源来理解如何有效修复漏洞。</p></li><li><p><strong>依赖社区更新</strong> 由于 Seay 是一个开源项目，它的更新频率可能不如商业产品及时。如果新的漏洞或安全问题未能及时更新规则库，可能会导致某些漏洞被漏掉。</p></li></ol><h2 id="5-9-360-代码卫士"><a href="#5-9-360-代码卫士" class="headerlink" title="5.9 360 代码卫士"></a>5.9 360 代码卫士</h2><p><strong>360 代码卫士</strong> 是360公司推出的一款专注于源代码安全审计的工具，旨在帮助开发者和安全人员识别和修复代码中的安全漏洞。</p><h3 id="5-9-1-优点："><a href="#5-9-1-优点：" class="headerlink" title="5.9.1 优点："></a>5.9.1 <strong>优点：</strong></h3><ol><li><p><strong>全面的漏洞检测</strong> 360 代码卫士具有强大的漏洞检测能力，能够发现包括 SQL 注入、XSS、路径遍历、命令注入等多种常见的安全漏洞。它通过静态分析技术对代码进行深度扫描，帮助开发者尽早发现潜在的安全问题。</p></li><li><p><strong>多语言支持</strong> 360 代码卫士支持多种编程语言和框架，包括 Java、C&#x2F;C++、Python、PHP、Go 等常见的开发语言。它能够满足不同开发环境的需求，适用于多种应用程序类型。</p></li><li><p><strong>集成开发工具链</strong> 360 代码卫士可以与多种开发工具和平台（如 Git、Jenkins、Maven 等）进行集成，帮助开发者将源代码审计融入到日常的开发流程中。它的自动化集成功能能够提高开发效率，推动 DevSecOps 实践。</p></li><li><p><strong>支持多种漏洞扫描规则</strong> 360 代码卫士提供了丰富的漏洞扫描规则，能够覆盖常见的安全漏洞和一些特定行业的安全要求。同时，它也支持用户自定义规则，满足特定项目的安全需求。</p></li><li><p><strong>友好的用户界面</strong> 360 代码卫士的用户界面简洁易用，即便是没有安全背景的开发人员也能较为轻松地进行配置和使用。它的可视化报告能够帮助用户快速识别和定位代码中的安全漏洞。</p></li><li><p><strong>自动化修复建议</strong> 360 代码卫士在漏洞报告中，除了指出漏洞所在，还提供了针对性的修复建议。这样可以帮助开发人员更快速地修复安全问题，提高工作效率。</p></li><li><p><strong>安全性高</strong> 360 代码卫士来自国内知名的安全公司360，具有较强的安全性保障，并能够保证审计数据的安全性和隐私保护。这对于一些对数据安全有较高要求的企业来说尤为重要。</p></li></ol><h3 id="5-9-2-缺点："><a href="#5-9-2-缺点：" class="headerlink" title="5.9.2 缺点："></a>5.9.2 <strong>缺点：</strong></h3><ol><li><p><strong>误报和漏报</strong> 360 代码卫士虽然具有较强的漏洞检测能力，但仍然存在误报和漏报的情况，尤其是在一些复杂的代码结构和不常见的安全漏洞场景下。开发人员需要花费一定的时间进行人工审核和确认。</p></li><li><p><strong>对复杂代码的适应性差</strong> 对于一些非常复杂的、使用特定框架和库的代码，360 代码卫士可能无法精准地识别所有潜在漏洞，导致部分漏洞无法被及时发现。    </p></li><li><p><strong>功能相对局限</strong> 尽管360 代码卫士支持静态代码分析，但它的功能相对局限，主要集中在安全漏洞检测上。对于一些动态分析（例如运行时漏洞）或更复杂的漏洞类型，可能需要与其他工具结合使用。</p></li></ol><h2 id="5-10-奇安信代码审计卫士"><a href="#5-10-奇安信代码审计卫士" class="headerlink" title="5.10 奇安信代码审计卫士"></a>5.10 奇安信代码审计卫士</h2><p><strong>奇安信代码审计卫士</strong> 是奇安信公司推出的一款专注于代码审计的工具，主要用于帮助开发人员和企业团队检测和修复代码中的潜在漏洞和安全隐患。它通过静态代码分析、漏洞检测等技术，确保软件在开发和发布前具备良好的安全性和质量。</p><h3 id="5-10-1-优点："><a href="#5-10-1-优点：" class="headerlink" title="5.10.1 优点："></a>5.10.1 <strong>优点：</strong></h3><ol><li><p><strong>全面的漏洞检测</strong> 奇安信代码审计卫士能够全面扫描源代码，识别多种安全漏洞，包括但不限于 SQL 注入、跨站脚本（XSS）、缓冲区溢出、权限管理问题、资源泄露等。它能够发现常见的安全问题，并提供详细的报告和修复建议。</p></li><li><p><strong>支持多种编程语言</strong> 支持多种编程语言的代码审计，如 Java、C&#x2F;C++、Python、Go、PHP 等。开发团队可以根据项目的具体需求，使用适合的语言进行静态分析，覆盖广泛的开发环境。</p></li><li><p><strong>智能化的漏洞识别</strong> 该工具使用智能算法对代码进行静态分析，能够有效识别代码中的潜在风险，分析逻辑漏洞并提供合理的修复建议。这对于开发人员在代码编写过程中起到了预警和优化的作用。</p></li><li><p><strong>集成开发环境的支持</strong> 奇安信代码审计卫士可以与常见的开发工具链（如 Git、Jenkins、Maven 等）集成，支持 CI&#x2F;CD 流程。可以实时触发代码审计，并将报告自动生成，确保安全问题能够及时发现并修复。</p></li><li><p><strong>高效的扫描速度</strong> 相较于其他同类工具，奇安信代码审计卫士提供了较为高效的扫描速度，能够在短时间内完成大规模代码库的分析，有助于提升开发效率。</p></li><li><p><strong>定制化安全规则</strong> 支持根据企业的具体需求和业务场景定制化安全规则，满足不同项目的安全审计需求。用户可以根据自己的业务需求，设定专属的安全扫描策略。</p></li><li><p><strong>易于部署与使用</strong> 奇安信代码审计卫士的安装和部署相对简单，用户可以在本地环境或云端快速部署，并且其界面友好，易于上手。它提供了简洁的可视化报告，方便开发人员查看和理解审计结果。</p></li><li><p><strong>合规性支持</strong> 工具支持针对多种行业标准和法规的合规性检测，如 OWASP Top 10、CWE&#x2F;SANS Top 25 等，有助于帮助企业满足相关安全合规要求，尤其适用于涉及敏感数据和行业监管的公司。</p></li></ol><h3 id="5-10-2-缺点："><a href="#5-10-2-缺点：" class="headerlink" title="5.10.2 缺点："></a>5.10.2 <strong>缺点：</strong></h3><ol><li><p><strong>价格相对较高</strong> 作为商业化工具，奇安信代码审计卫士的价格可能相对较高，对于预算有限的中小型团队或企业来说，可能会觉得其成本较为庞大。与免费或开源工具相比，价格可能是一个考虑因素。</p></li><li><p><strong>对动态漏洞的支持不足</strong> 由于静态分析工具的特点，奇安信代码审计卫士主要聚焦于源代码的静态扫描，可能对于依赖运行时环境和外部因素的漏洞（如动态行为漏洞）支持不足，依赖于其他动态分析工具进行补充</p></li></ol><h2 id="5-11-总结"><a href="#5-11-总结" class="headerlink" title="5.11 总结"></a>5.11 总结</h2><ul><li>不同常见的代码审查工具，采用的代码审查技术不一样，扫描的结果存在差异，为了提高代码的安全性，建议采用多个工具进行补充比对。</li><li>代码审计工具只是辅助工具，核心代码、扫描结果仍需要人工进行判别和验证。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1 概念&quot;&gt;&lt;/a&gt;1 概念&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;源代码审计（Source Code Auditing）是指对软件源代码进行深入检查和分析，以识别其</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="代码审计" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="源代码安全审计" scheme="http://suzi007.github.io/tags/%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%89%E5%85%A8%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>Amas-域名枚举工具</title>
    <link href="http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/Amass/"/>
    <id>http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/Amass/</id>
    <published>2025-03-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:06:28.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-工具简介"><a href="#1-工具简介" class="headerlink" title="1 工具简介"></a>1 工具简介</h1><blockquote><p>Amass 是 OWASP 提供的一个强大的子域名枚举工具。它可以帮助用户通过多种数据源来发现目标域名的子域名，以及一些相关的网络信息。Amass 支持主动扫描和被动扫描，并且可以通过配置文件进行自定义。</p></blockquote><h1 id="2-工具使用"><a href="#2-工具使用" class="headerlink" title="2 工具使用"></a>2 工具使用</h1><h2 id="2-1-枚举模块"><a href="#2-1-枚举模块" class="headerlink" title="2.1 枚举模块"></a>2.1 枚举模块</h2><blockquote><p>该子命令允许执行 DNS 枚举和目标映射以确定暴露的攻击面。它可以在被动或主动模式下运行。被动模式速度更快，但不验证 DNS 信息。</p></blockquote><blockquote><p>1、域名枚举：运行 enum 子命令而不指定主动或被动标志将从数据源中播种枚举，并利用 DNS 来验证结果并进一步调查范围内的命名空间。</p></blockquote><p>命令： <code>amass enum -d 192.168.1.10//子域名枚举</code></p><blockquote><p>2、使用被动数据源进行子域名枚举（只会从数据源获取信息并盲目接受）</p></blockquote><p>命令： <code>amass enum -passive -d 192.168.1.10 //使用被动数据源进行子域名枚举</code></p><blockquote><p>3、使用被动数据源进行子域名枚举</p></blockquote><p>命令： <code>amass enum -config config.ini -d 192.168.1.10//使用自定义数据源进行子域名枚举</code><br>Amass 使用大量外部资源来获取您想要的信息。对于某些服务，这涉及使用 API 密钥(config.ini 配置)。</p><blockquote><p>4、保存输出结果</p></blockquote><p>命令： <code>amass enum -d 192.168.1.10 -o output.txt//结果保存为文本文件</code><br>&#96;</p><blockquote><p>5、枚举多个域名</p></blockquote><p>命令： <code>amass enum -df domain.txt//枚举多个域名，文件中每一行一个域名</code></p><blockquote><p>5、主动模式（将执行所有正常模式并访问已发现的资产并尝试获取 TLS 证书、执行 DNS 区域传输、使用 NSEC 行走以及执行网络爬行）。</p></blockquote><p>命令： <code>amass enum -active -d example.com -p 80,443,8080</code></p><h2 id="2-2-intel-模块"><a href="#2-2-intel-模块" class="headerlink" title="2.2 intel 模块"></a>2.2 intel 模块</h2><blockquote><p>intel 子命令可以帮助您发现与您正在调查的组织关联的其他根域名。该子命令利用配置文件的数据源部分来获取被动情报，例如反向 whois 信息。</p></blockquote><blockquote><p>1、启用主动侦察方法</p></blockquote><p>命令： <code>amass intel -active -addr //枚举多个域名，文件中每一行一个域名</code></p><blockquote><p>2、IP 和范围 (192.168.1.1-254) 以逗号分隔</p></blockquote><p>命令：<code>amass intel -addr 192.168.2.1-64</code></p><blockquote><p>3、根据域名 whois 查询(所有发现的域名都通过反向 whois 运行)</p></blockquote><p>命令：<code>amass intel -whois -d example.com</code></p><blockquote><p>4、提供根域名的文件的路径</p></blockquote><p>命令：<code>amass intel -whois -df domains.txt</code></p><blockquote><p>5、显示已发现名称的 IP 地址</p></blockquote><p>命令：<code>amass intel -ip -whois -d example.com</code></p><h1 id="3-注意事项"><a href="#3-注意事项" class="headerlink" title="3 注意事项"></a>3 注意事项</h1><p>Amass 使用大量外部资源来获取您想要的信息。对于某些服务，这涉及使用 API 密钥(config.ini 配置)，需要花费费用进行使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-工具简介&quot;&gt;&lt;a href=&quot;#1-工具简介&quot; class=&quot;headerlink&quot; title=&quot;1 工具简介&quot;&gt;&lt;/a&gt;1 工具简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Amass 是 OWASP 提供的一个强大的子域名枚举工具。它可以帮助用户通过多种</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/kaliTool/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/tags/kaliTool/"/>
    
  </entry>
  
  <entry>
    <title>chainsaw-Windows日志分析工具</title>
    <link href="http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/chainsaw/"/>
    <id>http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/chainsaw/</id>
    <published>2025-03-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:19:57.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-工具介绍"><a href="#1-工具介绍" class="headerlink" title="1 工具介绍"></a>1 工具介绍</h1><blockquote><p>处理和搜索事件日志可能是一个缓慢而耗时的过程，并且在大多数情况下，需要周围基础设施(例如ELK<a href="https://zhida.zhihu.com/search?content_id=235024753&content_type=Article&match_order=1&q=%E5%A0%86%E6%A0%88&zhida_source=entity">堆栈</a>或Splunk实例)的开销来有效地搜索日志数据并应用检测逻辑。这种开销通常意味着蓝色团队无法快速分类Windows事件日志，以提供进行调查所需的方向和结论。Chainsaw 是一款基于 Windows 事件日志的信息安全取证工具，该工具提供了强大的“第一时间响应”能力，可以帮助广大研究人员快速识别 Windows 事件日志中的威胁。</p></blockquote><h1 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2 基本使用"></a>2 基本使用</h1><h2 id="2-1-预备基础知识"><a href="#2-1-预备基础知识" class="headerlink" title="2.1 预备基础知识"></a>2.1 预备基础知识</h2><blockquote><p>Windows 事件日志文件保存在 <code>%SystemRoot%\System32\Winevt\Logs</code> 路径中。可以使用 chainsaw 工具分析 window 日志。</p></blockquote><blockquote><p>常见日志文件主要有三个，分别是：<code>System.evtx</code> 、<code>Application.evtx</code> 和 <code>Security.evtx</code>。分别是系统日志、应用程序日志和安全日志。</p></blockquote><ul><li><p>System.evtx</p><p>  记录操作系统自身组件产生的日志事件，比如驱动、系统组件和应用软件的崩溃以及数据丢失错误等等。</p></li><li><p>Application.evtx</p><p>  记录应用程序或系统程序运行方面的日志事件，比如数据库程序可以在应用程序日志中记录文件错误，应用的崩溃记录等。</p></li><li><p>Security.evtx</p><p>  记录系统的安全审计日志事件，比如登录事件、对象访问、进程追踪、特权调用、帐号管理、策略变更等。<code>Security.evtx</code>也是取证中最常用到的。</p></li></ul><blockquote><p>默认情况下，当一个<code>evtx</code>文件的记录满了，日志服务会覆盖最开始的记录，从头开始写入新的记录。也就是相当于一个循环记录的缓存文件。</p></blockquote><h2 id="2-2-日志搜索"><a href="#2-2-日志搜索" class="headerlink" title="2.2 日志搜索"></a>2.2 日志搜索</h2><blockquote><p>1、在所有 .evtx 文件中搜索不区分大小写的字符串“mimikatz”</p></blockquote><p>命令： <code>./chainsaw search mimikatz -i evtx_attack_samples/</code></p><blockquote><p>2、在所有 .evtx 文件中搜索 powershell 脚本阻止事件 (事件 ID 4014)</p></blockquote><p>命令： <code>./chainsaw search -t &#39;Event.System.EventID: =4104&#39; evtx_attack_samples/</code></p><blockquote><p>3、使用匹配的正则表达式模式在特定的 evtx 日志中搜索登录事件，以 JSON 格式输出</p></blockquote><p>命令： <code>./chainsaw search -e &quot;DC[0-9].insecurebank.local&quot; evtx_attack_samples --json</code></p><h2 id="2-3-日志取证"><a href="#2-3-日志取证" class="headerlink" title="2.3 日志取证"></a>2.3 日志取证</h2><blockquote><p>1、通过使用内置的 Sigma 检测规则搜索所有 evtx 文件识别可疑威胁</p></blockquote><p>命令： <code>./chainsaw hunt evtx_attack_samples/ -s sigma/ --mapping mappings/sigma-event-logs-all.yml</code></p><blockquote><p>2、使用 Sigma 规则和 Chainsaw 规则搜索所有 evtx 文件以了解检测逻辑，并以 CSV 格式输出到结果文件夹</p></blockquote><p>命令： <code>./chainsaw hunt evtx_attack_samples/ -s sigma/ --mapping mappings/sigma-event-logs-all.yml -r rules/ --csv --output results</code></p><blockquote><p>3、使用 Sigma 规则搜索所有 evtx 文件以获取检测逻辑，仅在特定时间戳之间搜索，并以 JSON 格式输出结果</p></blockquote><p>命令： <code>./chainsaw hunt evtx_attack_samples/ -s sigma/ --mapping mappings/sigma-event-logs-all.yml --from &quot;2019-03-17T19:09:39&quot; --to &quot;2019-03-17T19:09:50&quot; --json</code></p><h2 id="2-4-日志分析"><a href="#2-4-日志分析" class="headerlink" title="2.4 日志分析"></a>2.4 日志分析</h2><blockquote><p>1、使用提供的正则表达式模式分析 shimcache 工件，并使用启用了时间戳近对检测的 amcache 丰富功能。输出到 csv 文件。</p></blockquote><p>命令： <code>./chainsaw analyse shimcache ./SYSTEM --regexfile ./analysis/shimcache_patterns.txt --amcache ./Amcache.hve --tspair --output ./output.csv</code></p><blockquote><p>2、使用提供的正则表达式模式（不使用 amcache 丰富）分析 shimcache 工件。输出到终端。</p></blockquote><p>命令： <code>./chainsaw analyse shimcache ./SYSTEM --regexfile ./analysis/shimcache_patterns.txt</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-工具介绍&quot;&gt;&lt;a href=&quot;#1-工具介绍&quot; class=&quot;headerlink&quot; title=&quot;1 工具介绍&quot;&gt;&lt;/a&gt;1 工具介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;处理和搜索事件日志可能是一个缓慢而耗时的过程，并且在大多数情况下，需要周围基础设施</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/kaliTool/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/tags/kaliTool/"/>
    
  </entry>
  
  <entry>
    <title>Searchsploit-渗透测试工具</title>
    <link href="http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/Searchsploit/"/>
    <id>http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/Searchsploit/</id>
    <published>2025-03-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:17:59.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-工具介绍"><a href="#1-工具介绍" class="headerlink" title="1 工具介绍"></a>1 工具介绍</h1><p>Searchsploit 是一款基于命令行的搜索工具，专为 Exploit-DB 设计。Exploit-DB 是一个由 Offensive Security 赞助的开源漏洞利用程序数据库，包含了大量的漏洞信息和渗透脚本。Searchsploit 允许用户通过简单的命令，在 Exploit-DB 中快速搜索和定位所需的漏洞信息。<a href="https://www.exploit-db.com/">Exploit-DB在线查询地址</a>。</p><h1 id="2-工具使用"><a href="#2-工具使用" class="headerlink" title="2 工具使用"></a>2 工具使用</h1><h2 id="2-1-命令参数"><a href="#2-1-命令参数" class="headerlink" title="2.1 命令参数"></a>2.1 命令参数</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">命令参数：</span><br><span class="line">-c，--case [Term]：执行区分大小写的搜索，默认搜索对大小写不敏感。</span><br><span class="line">-e，--exact [Term]：对exploit标题执行EXACT匹配（默认为AND）。</span><br><span class="line">-j，--json [Term]：以JSON格式显示结果。</span><br><span class="line">-m，--mirror [EDB-ID]：将一个漏洞利用镜像副本到当前工作目录。</span><br><span class="line">-o，--overflow [Term]： exploit标题被允许溢出其列。</span><br><span class="line">-p，--path [EDB-ID]：显示漏洞利用的完整路径。如果可能， 还将复制路径到粘贴板。</span><br><span class="line">-t，--title [Term]：仅仅搜索漏洞标题，默认是标题和文件的路径。</span><br><span class="line">-u，--update [Term]：检查并安装任何exploit-db软件包更新。</span><br><span class="line">-w，--www [Term]：显示exploit-db.com的URL而不是本地路径（在线搜索）。</span><br></pre></td></tr></table></figure><h2 id="2-2-常规使用"><a href="#2-2-常规使用" class="headerlink" title="2.2 常规使用"></a>2.2 常规使用</h2><blockquote><p>0、更新漏洞库（建议每次使用前更新以下漏洞库）</p></blockquote><p>命令：<code>searchsploit -u</code></p><blockquote><p>1、搜索漏洞信息（搜索与“Apache Struts”相关的漏洞信息）</p></blockquote><p>命令：<code>searchsploit apache struts</code></p><blockquote><p>2、复制漏洞利用脚本到本地</p></blockquote><p>命令：<code>searchsploit -m 42031.py</code></p><blockquote><p>3、修改漏洞脚本，将漏洞脚本需要的基本信息进行补充</p></blockquote><blockquote><p>4、执行漏洞脚本</p></blockquote><h2 id="2-3-高级用法"><a href="#2-3-高级用法" class="headerlink" title="2.3 高级用法"></a>2.3 高级用法</h2><blockquote><p>1、搜索具有 CVE 编号的漏洞信息</p></blockquote><p>命令：<code>searchsploit --cve 2021-44228</code></p><blockquote><p>2、输出脚本到制定路径中</p></blockquote><p>命令：<code>searchsploit -p 39446</code></p><blockquote><p>3、搜索标题中包含 item 信息的漏洞</p></blockquote><p>命令：<code>searchsploit -t oracle windows</code></p><blockquote><p>4、搜索必须包含内容</p></blockquote><p>命令：<code>searchsploit -s Apache Struts 2.0.0</code></p><blockquote><p>5、搜索漏洞信息排除内容包含 PoC 或者&#x2F;dos&#x2F;内容</p></blockquote><p>命令：<code>searchsploit linux kernel 3.2 --exclude=&quot;(PoC)|/dos/&quot;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-工具介绍&quot;&gt;&lt;a href=&quot;#1-工具介绍&quot; class=&quot;headerlink&quot; title=&quot;1 工具介绍&quot;&gt;&lt;/a&gt;1 工具介绍&lt;/h1&gt;&lt;p&gt;Searchsploit 是一款基于命令行的搜索工具，专为 Exploit-DB 设计。Exploit-DB</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/kaliTool/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/tags/kaliTool/"/>
    
  </entry>
  
  <entry>
    <title>findomain-域名识别工具</title>
    <link href="http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/findomain/"/>
    <id>http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/findomain/</id>
    <published>2025-03-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:07:37.036Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-工具介绍"><a href="#1-工具介绍" class="headerlink" title="1 工具介绍"></a>1 工具介绍</h1><blockquote><p>findomain 是一款快速而全面的域名识别工具，助力安全人员发现目标关联域名，为渗透测试提供重要信息支持。于 2024 年 4 月份 kali 更新后加入 kali 大家庭。主要功能包括：</p></blockquote><ul><li>子域名监控：将数据发送至 Discord、Slack 或 Telegram Webhooks。更多信息见<a href="https://gitcode.com/gh_mirrors/fin/findomain/blob/master/README.md#subdomains-monitoring">子域名监控</a>。</li><li>API查询的多线程支持，确保 Findomain 对任何目标查找子域名的最大时间不超过15秒（API超时时）。</li><li>子域名解析的并行支持，网络条件良好时每分钟可解析约3.5k个子域名。</li><li>支持DNS over TLS。</li><li>支持特定IPv4或IPv6查询。</li><li>不依赖暴力破解来发现子域名，该工具利用证书透明度日志和API。</li><li>仅发现已解析的子域名。</li><li>发现子域名的IP以供数据分析。</li><li>从命令行参数(-t)或文件(-f)读取目标。</li><li>将所有或仅已解析的子域名写入用户指定的单一输出文件。</li><li>将结果写入自动命名的TXT输出文件。</li><li>能够查询之前通过<a href="https://gitcode.com/gh_mirrors/fin/findomain/blob/master/docs/INSTALLATION.md#subdomains-monitoring">子域名监控</a>发现的子域名的Findomain数据库。</li><li>能够导入和处理其他工具发现的数据。</li><li>静默模式运行。</li><li>跨平台支持：任何平台，因为它是用Rust编写的，而Rust是跨平台的。具体步骤参阅<a href="https://gitcode.com/gh_mirrors/fin/findomain/blob/master/docs/INSTALLATION.md#build-for-32-bits-or-another-platform">文档</a>。</li><li>多重API支持。</li><li>作为子域名解析器的可能。</li><li>准确的结果，具备子域名通配符检测。</li><li>支持TOML、JSON、HJSON、INI或YAML格式的配置文件。</li><li>可自定义DNS IP地址以快速解析子域名，默认情况下超过60次每秒，可通过<code>--threads</code>选项调整。</li></ul><h1 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2 环境配置"></a>2 环境配置</h1><blockquote><p>1、在 kali 中 更新软件源（2024.4 版）</p></blockquote><p>命令：<code>sudo apt update</code></p><blockquote><p>2、执行安装命令：</p></blockquote><p><code>sudo apt install findomain</code></p><h1 id="3-基础用法"><a href="#3-基础用法" class="headerlink" title="3 基础用法"></a>3 基础用法</h1><blockquote><ol><li>搜索子域名并在屏幕上打印信息：</li></ol></blockquote><p><code>findomain -t example.com</code></p><blockquote><ol start="2"><li>搜索子域并将数据导出到输出文件（本例中的输出文件名为 example.com.txt）：</li></ol></blockquote><p><code>findomain -t example.com -o</code></p><blockquote><ol start="3"><li>搜索子域并将数据导出到自定义输出文件名：</li></ol></blockquote><p><code>findomain -t example.com -u example.txt</code></p><blockquote><ol start="4"><li>仅搜索可解析的子域：</li></ol></blockquote><p><code>findomain -t example.com -r</code></p><blockquote><ol start="5"><li>仅搜索可解析的子域，并将数据导出到自定义输出文件。</li></ol></blockquote><p><code>findomain -t example.com -r -u example.txt</code></p><blockquote><ol start="6"><li>从使用文件传递的域列表中搜索子域（您需要将文件的每一行都放入一个域）：</li></ol></blockquote><p><code>findomain -f file_with_domains.txt</code></p><blockquote><ol start="7"><li>从使用文件传递的域列表中搜索子域（您需要在文件中的每一行中放入一个域）并将所有已解析的域保存到自定义文件名中：</li></ol></blockquote><p><code>findomain -f file_with_domains.txt -r -u multiple_domains.txt</code></p><blockquote><ol start="8"><li><a href="https://gitcode.com/gh_mirrors/fin/findomain/blob/master/docs/INSTALLATION.md#subdomains-monitoring">查询使用子域监控</a>创建的 Findomain 数据库。</li></ol></blockquote><p><code>findomain -t example.com --query-database</code></p><blockquote><ol start="9"><li><a href="https://gitcode.com/gh_mirrors/fin/findomain/blob/master/docs/INSTALLATION.md#subdomains-monitoring">查询使用子域监控</a>创建的 Findomain 数据库并将结果保存为自定义文件名。</li></ol></blockquote><p><code>findomain -t example.com --query-database -u subdomains.txt</code></p><blockquote><ol start="10"><li><a href="https://gitcode.com/gh_mirrors/fin/findomain/blob/master/docs/INSTALLATION.md#subdomains-monitoring">从多个文件导入子域名并在子域名监控</a>过程中使用它们：</li></ol></blockquote><p><code>findomain --import-subdomains file1.txt file2.txt file3.txt -m -t example.com</code></p><h1 id="4-高级功能"><a href="#4-高级功能" class="headerlink" title="4 高级功能"></a>4 高级功能</h1><p>其他高级功能详见： <a href="https://github.com/Findomain/Findomain">https://github.com/Findomain/Findomain</a></p><h1 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5 注意事项"></a>5 注意事项</h1><blockquote><p>高级功能需要配置SecurityTrails API ，详细步骤详见 <a href="https://gitcode.com/gh_mirrors/fin/findomain/blob/master/docs/INSTALLATION.md#access-tokens-configuration">https://gitcode.com/gh_mirrors/fin/findomain/blob/master/docs/INSTALLATION.md#access-tokens-configuration</a> 。免费版需要翻墙＋公司邮箱+每月限制 50 次查询。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-工具介绍&quot;&gt;&lt;a href=&quot;#1-工具介绍&quot; class=&quot;headerlink&quot; title=&quot;1 工具介绍&quot;&gt;&lt;/a&gt;1 工具介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;findomain 是一款快速而全面的域名识别工具，助力安全人员发现目标关联域名，</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/kaliTool/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/tags/kaliTool/"/>
    
  </entry>
  
  <entry>
    <title>wfuzz-爆破工具</title>
    <link href="http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/wfuzz/"/>
    <id>http://suzi007.github.io/2025/03/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/wfuzz/</id>
    <published>2025-03-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:16:38.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-wfuzz"><a href="#1-wfuzz" class="headerlink" title="1 wfuzz"></a>1 wfuzz</h1><blockquote><p>该工具可以提供的主要功能包括：</p></blockquote><ul><li>目录扫描</li><li>找参数</li><li>密码爆破 username password</li><li>找 SQL，XSS</li><li>压力测试</li></ul><blockquote><p>该工具自带字典路径（kali 2024 版）<br><code>/usr/share/wfuzz/wordlist</code></p></blockquote><h2 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h2><blockquote><p>1、目录扫描</p></blockquote><p>命令：<code>wfuzz -w dir.txt --hc 404 http://testphp.vulnweb.com/FUZZ/</code></p><blockquote><p>2、爆破参数</p></blockquote><p>命令：<code>wfuzz -w dir.txt --hc 404 http://testphp.vulnweb.com/index.html?FUZZ=1</code></p><blockquote><p>3、密码爆破</p></blockquote><p>命令：<code>wfuzz -w user.txt -w pwd.txt --hc 404 http://testphp.vulnweb.com/index.html?username=FUZZ&amp;pwd=FUZ2Z</code></p><ul><li>–hc 取除 404 状态码响应结果</li><li>FUZZ、FUZ 1 Z、FUZ 3 Z 为占位符，按顺序从提供的字典</li></ul><blockquote><p>4、Post 数据爆破</p></blockquote><p>命令：<code>wfuzz -w userList -w pwdList -d &quot;username=FUZZ&amp;password=FUZ2Z&quot; http://127.0.0.1/login.php</code></p><ul><li>-d 参数传输 POST 请求正文。</li></ul><blockquote><p>5、Cookie 测试</p></blockquote><p>命令：<code>wfuzz -z range,000-999 -b session=session -b cookie=cookie http://127.0.0.1/getuser.php?uid=FUZZ</code></p><ul><li>-z  构造 0-999 递增变量</li><li>-b 指定 cookie 内容</li></ul><blockquote><p>6、http 的 Headers 爆破</p></blockquote><p>命令：<code>wfuzz -z range,0000-9999 -H &quot;X-Forwarded-For: FUZZ&quot; http://127.0.0.1/get.php?userid=666</code></p><blockquote><p>7、请求方法爆破</p></blockquote><p>命令：<code>wfuzz -z list, &quot;GET-POST-HEAD-PUT&quot; -X FUZZ http://127.0.0.1/ </code></p><ul><li>-z list 参数 可以自定义一个字典列表( 在命令中体现 )，以 - 分割。因为这里要测试 HTTP 请求方法，所以 字典列表为 GET-POST-HEAD-PUT</li><li>-X 参数 指定 HTTP 请求方法类型，后面的值为 FUZZ 占位符。</li></ul><blockquote><p>8、使用代理</p></blockquote><p>命令：<code>wfuzz -w wordlist -p proxtHost:proxyPort:TYPE URL/FUZZ</code></p><ul><li>-p 参数指定主机:端口:代理类型，多个代理可使用多个-p参数同时指定  wfuzz 每次请求都会选取不同的代理进行。</li></ul><blockquote><p>9、认证（测试 HTTP Basic Auth 保护命令）</p></blockquote><p>命令：<code>wfuzz -z list,&quot;username-password&quot; --basic FUZZ:FUZZ URL  </code></p><ul><li>wfuzz 可以通过 –basec –ntml –digest 来设置认证头，</li></ul><blockquote><p>10、递归测试（常用于目录爆破）</p></blockquote><p>命令：<code>wfuzz -z list,&quot;admin-login.php-test-dorabox&quot; -R 2 http://127.0.0.1/FUZZ</code></p><ul><li>-R 参数可以指定一个 payload 被递归的深度(数字)。</li></ul><blockquote><p>11、并发、请求间隔（常用于绕过安全设备）</p></blockquote><p>命令：<code>wfuzz -z range,0-20 -t 20 -s 1 -d &quot;money=1&quot; http://127.0.0.1/dorabox/race_condition/pay.php?FUZZ</code></p><ul><li>使用 -t 参数 设置 并发请求，该参数默认设置都是 10。  </li><li>使用 -s 参数 设置 每次发送HTTP的时间间隔。</li></ul><blockquote><p>12、保存测试结果</p></blockquote><p>命令：<code>wfuzz -f outfile,json -w wordlist URL/FUZZ</code></p><ul><li>支持 raw、json、csv、HTML、</li></ul><h2 id="1-2-高级用法"><a href="#1-2-高级用法" class="headerlink" title="1.2 高级用法"></a>1.2 高级用法</h2><h3 id="1-2-1-迭代器（多个参数迭代规则）"><a href="#1-2-1-迭代器（多个参数迭代规则）" class="headerlink" title="1.2.1 迭代器（多个参数迭代规则）"></a>1.2.1 迭代器（多个参数迭代规则）</h3><blockquote><p>wfuz z自带的迭代器有三个：zip、chain、product，如果不指定迭代器，默认为 product 迭代器，通过使用迭代器，使 wfuzz 工具具备与 burp suite Intruder 模块-Attack Type 功能（Sniper、Battering ram、Pitchfork、Cluster bomb(）</p></blockquote><blockquote><p>1、zip 迭代器：字典数相同、一一对应进行组合，如果字典数不一致则多余的抛弃掉不请求，</p></blockquote><p>命令：<code>wfuzz -z range,0-9 -w dict.txt -m zip http://127.0.0.1/ip.php?FUZZ=FUZ2Z</code></p><blockquote><p>2、chain 迭代器：将所有字典全部整合(不做组合)放在一起然后传入占位符FUZZ中。</p></blockquote><p>命令：<code>wfuzz -z range,0-9 -w dict.txt -m chain http://127.0.0.1/ip.php?FUZZ</code></p><blockquote><p>3、product 迭代器：请求的参数交叉组合</p></blockquote><p>命令：<code>wfuzz -z range,0-2 -w dict.txt -m product http://127.0.0.1/ip.php?FUZZ=FUZ2Z</code></p><h3 id="1-2-2-编码转换功能"><a href="#1-2-2-编码转换功能" class="headerlink" title="1.2.2 编码转换功能"></a>1.2.2 编码转换功能</h3><blockquote><p>1、Encoders 的 md5 加密功能</p></blockquote><p>命令：<code>wfuzz -z file,pwd.txt,md5 URL/FUZZ</code></p><h3 id="1-2-3-插件功能（scripts）"><a href="#1-2-3-插件功能（scripts）" class="headerlink" title="1.2.3 插件功能（scripts）"></a>1.2.3 插件功能（scripts）</h3><blockquote><p>wfuzz 是支持插件的，其本身也有很多插件，插件大部分都是实现扫描和解析功能，插件共有两大类和一类附加插件：</p></blockquote><ul><li>passive：分析已有的请求和响应(被动)</li><li>active：会向目标发送请求来探测(主动)</li><li>discovery：自动帮助wfuzz对目标站进行爬取，将发现的内容提供给wfuzz进行请求</li></ul><blockquote><p>1、查看自带脚本</p></blockquote><p>命令：<code>wfuzz -e scripts</code></p><blockquote><p>2、查询脚本帮助信息</p></blockquote><p>命令：<code>wfuzz --script-help=robots</code></p><h3 id="1-2-4-其他高级功能"><a href="#1-2-4-其他高级功能" class="headerlink" title="1.2.4 其他高级功能"></a>1.2.4 其他高级功能</h3><blockquote><p>1、忽略网络异常，使用 -Z 参数即可忽略这些错误继续执行。</p></blockquote><blockquote><p>2、超时错误，使用 wfuzz 扫描会遇到一些响应很慢的情况，wfuzz 可以设置超时时间。  参数 –conn-delay 来设置 wfuzz 等待服务器响应接连的秒数。参数 –req-delay 来设置 wfuzz 等待响应完成的最大秒数</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-wfuzz&quot;&gt;&lt;a href=&quot;#1-wfuzz&quot; class=&quot;headerlink&quot; title=&quot;1 wfuzz&quot;&gt;&lt;/a&gt;1 wfuzz&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;该工具可以提供的主要功能包括：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/kaliTool/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/tags/kaliTool/"/>
    
  </entry>
  
  <entry>
    <title>KaliTool</title>
    <link href="http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/KaliTool/"/>
    <id>http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/KaliTool/</id>
    <published>2024-04-17T07:26:29.000Z</published>
    <updated>2025-03-29T15:56:51.669Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-信息收集"><a href="#1-信息收集" class="headerlink" title="1 信息收集"></a>1 信息收集</h1><h2 id="1-1-Amap"><a href="#1-1-Amap" class="headerlink" title="1.1 Amap"></a>1.1 Amap</h2><p>   Amap是一个服务扫描工具，它是最早被称为下一代扫描器的软件，可以识别不同的应用程序，即使这些程序运行在一个异常的端口上。Amap最早开始支持UDP协议和IPv6地址空间的扫描，可作为nmap重要的补充工具。同时amap还提供未知应用特征的自动测定功能，让我们可以方便定制扫描结果</p><h2 id="1-2-Arp-scan"><a href="#1-2-Arp-scan" class="headerlink" title="1.2 Arp-scan"></a>1.2 Arp-scan</h2><p>   Arp-scan是一个用来进行系统发现和指纹识别的命令行工具，它可以构建并发送ARP请求到指定的IP地址，并且显示返回的任何响应</p><h2 id="1-3-DMitry"><a href="#1-3-DMitry" class="headerlink" title="1.3 DMitry"></a>1.3 DMitry</h2><p>   DMitry是一个用C语言开发的UNIX&#x2F;（GUN）Linux命令行工具，能够收集目标主机尽可能多的信息，包括主机所在的子域、电子邮件地址、运行时间、TCP端口扫描、whois查询等。</p><h2 id="1-4-Dnmap"><a href="#1-4-Dnmap" class="headerlink" title="1.4   Dnmap"></a>1.4   Dnmap</h2><p>   Dnmap是一个能够在多台客户机上执行分布式nmap扫描的框架，它可以读取包括nmap命令的文件，并把该命令文件发给与之相连的多台客户机，在这些客户机上执行nmap文件中的命令。dnmap框架采用的是客户机&#x2F;服务器模式，服务器发布命令，客户机执行命令，从而实现分布式nmap扫描</p><h2 id="1-5-Dnsenum"><a href="#1-5-Dnsenum" class="headerlink" title="1.5 Dnsenum"></a>1.5 Dnsenum</h2><p>   Dnsenum通过执行多线程Perl脚本来枚举域的DNS信息，从而发现非相邻的IP块</p><h2 id="1-6-Fierce"><a href="#1-6-Fierce" class="headerlink" title="1.6 Fierce"></a>1.6 Fierce</h2><p>   Fierce不是一个IP地址扫描器，也不是一个DDos工具，它不是涉及来扫描整个互联网或执行任何非针对性的攻击的。它是一个Perl脚本，是一个侦察工具，可以对域进行快速扫描，用来定位公司网络内部和外部可能的目标</p><h2 id="1-7-Maltego"><a href="#1-7-Maltego" class="headerlink" title="1.7 Maltego"></a>1.7 Maltego</h2><p>   Maltego是一个独特的平台，用于向组织拥有和运营的环境传递清晰的威胁画面。Maltego的独特优势在于证明单点故障的复杂性和严重性以及网络设备间的信任问题</p><h2 id="1-8-Nmap"><a href="#1-8-Nmap" class="headerlink" title="1.8   Nmap"></a>1.8   Nmap</h2><p>   Nmap是一个免费的、开源的用于网络发现和安全审计的工具，可用于网络资产管理、网络服务升级管理、监控主机或服务正常运行等任务Nmap功能强大，可判断主机是否在线，判断主机运行的操作系统类型和版本，判断主机提供了哪些服务（应用程序名称和版本）、使用了什么类型的过滤器或防火墙，以及其他几十种特性。</p><h2 id="1-9-P-0-f"><a href="#1-9-P-0-f" class="headerlink" title="1.9 P 0 f"></a>1.9 P 0 f</h2><p>   P0f来对主机上的操作系统进行鉴别，即使是在系统上装有性能良好的防火墙的 p0f是一款被动探测工具,能够通过捕获并分析目标主机发出的数据包 NAT、负载均衡、应用代理等,它是一个万能的被动操作系统指纹工具。情况下也没有问题。同时p0f在网络分析方面功能强大,可以用它来分析</p><h2 id="1-10-Recon-NG"><a href="#1-10-Recon-NG" class="headerlink" title="1.10 Recon-NG"></a>1.10 Recon-NG</h2><p>   Recon-NG是由Python编写的一个开源的Web侦查(信息收集)框架, 成数据库，可把查询结果结构化存储在其中，有报告模块，把结果导出为报告。使用它可以自动地收集信息和网络侦查。其命令格式与Metasploit默认集</p><h2 id="1-11-Smtp-user-enum"><a href="#1-11-Smtp-user-enum" class="headerlink" title="1.11 Smtp-user-enum"></a>1.11 Smtp-user-enum</h2><p>   Smtp-user-enum大部分基于类Unix系统的邮件服务,采用操作系统账号作为邮件账号, 因此对于其邮件账号的探测，其实就等同于对操作系统账号的探测，以便进 行后续弱密码口令的破解。smtp-user-enum基于三种方法验证邮件账号是否 存在，同时支持基于字典的批量验证。</p><h2 id="1-12-Snmp-check"><a href="#1-12-Snmp-check" class="headerlink" title="1.12 Snmp-check"></a>1.12 Snmp-check</h2><p>   Snmp-check是一款基于默认或指定团体名,对目标设备进行信息批量查 询的工具,其默认支持Windows、类Unix、网络设备和打印机等。完全依靠 人工来监控大型网络的运行状态,是一种令人崩溃的任务。SNMP协议可以大 大简化系统和网络管理员的工作，实现问题的快速定位和排查。</p><h2 id="1-13-Unicornscan"><a href="#1-13-Unicornscan" class="headerlink" title="1.13 Unicornscan"></a>1.13 Unicornscan</h2><p>   Unicornscan是一款通过尝试连接用户系统(User-Land)分布式TCP&#x2F; IP堆栈获得信息和关联关系的端口扫描器。它是一个新的信息收集引擎,主 要用于安全研究和通讯测试，主要特点是精确、灵活而且高效。</p><h2 id="1-14-Wireshark"><a href="#1-14-Wireshark" class="headerlink" title="1.14 Wireshark"></a>1.14 Wireshark</h2><p>   Wireshark从Ethereal发展而来,是一款网络数据包捕获和分析工具, 它使用WinPcap作为接口,可跳过TCP&#x2F;IP协议栈直接与网卡进行数据包的 交换。</p><h1 id="2-二、脆弱性分析"><a href="#2-二、脆弱性分析" class="headerlink" title="2 二、脆弱性分析"></a>2 二、脆弱性分析</h1><h2 id="2-1-BQSQL"><a href="#2-1-BQSQL" class="headerlink" title="2.1 BQSQL"></a>2.1 BQSQL</h2><p>   BQSQL是一款用Python写的SQL盲注框架,对SQL注入漏洞 攻击非常有效。它是一种半自动工具,自带一个直观的UI用户界 面,允许许多难以触发的SQL注入变得用户化,使设置攻击更容易。BBQSQL用法非常灵活,与数据库无关,不关心数据或数据库,而大 多数SQL注入工具是要具体的数据库或语言建立的。</p><h2 id="2-2-BED"><a href="#2-2-BED" class="headerlink" title="2.2  BED"></a>2.2  BED</h2><p>   BED(Bruteforce Exploit Detector)是一款缓存区漏洞检测 工具。它预置了十一种插件。这些插件针对不同的服务或系统，如 FTP、SMTP、POP等。同时,这些插件内包含了已知的各种攻击载荷。BED通过加载插件,向目标主机发送攻击数据。如果发现目标无法响 应，说明目标可能存在溢出区漏洞。经过多次测试验证，就可以判断 漏洞出现的位置。然后手工执行验证，采用代码审核、反编译等方式， 就可以找出漏洞具体触发机制，从而加以利用</p><h2 id="2-3-Cisco-auditing-tool"><a href="#2-3-Cisco-auditing-tool" class="headerlink" title="2.3 Cisco-auditing-tool"></a>2.3 Cisco-auditing-tool</h2><p>   Cisco-auditing-tool简称CAT,是一款小型的安全审计工具, 可检测出Cisco路由器常见的漏洞,可发现注入默认密码、默认 SNMP字符串和老版本IOS上存在的漏洞。</p><h2 id="2-4-Cisco-global-exploiter"><a href="#2-4-Cisco-global-exploiter" class="headerlink" title="2.4 Cisco-global-exploiter"></a>2.4 Cisco-global-exploiter</h2><p>   Cisco-global-exploiter是一个小型的Perl脚本,是一个针对 思科设备的漏洞利用工具合集,支持对思科设备的14种独立的漏洞 进行测试。</p><h2 id="2-5-Cisco-torch"><a href="#2-5-Cisco-torch" class="headerlink" title="2.5 Cisco-torch"></a>2.5 Cisco-torch</h2><p>   Cisco-torch是一款专门针对思科设备的扫描工具,它具备多种 应用层协议的指纹识别特性，借助与第三方指纹库的比对，可以轻 松识别目标设备及系统类型。同时由于采用了多线程的开发方式， 所以在性能上torch也同样表现突出。另外在密码破解和漏洞利用 方面, torch也具备相应的能力。如果torch破解了设备读写权限的 SNMP Community,还可进一步利用其获取设备的完整配置信息。</p><h2 id="2-6-Copy-router-config"><a href="#2-6-Copy-router-config" class="headerlink" title="2.6 Copy-router-config"></a>2.6 Copy-router-config</h2><p>   Copy-router-config专门针对思科设备而设计,利用SNMP协议 下载和上传思科设备的配置文件。其使用需要tftp服务的配合。</p><h2 id="2-7-Lynis"><a href="#2-7-Lynis" class="headerlink" title="2.7 Lynis"></a>2.7 Lynis</h2><p>   Lynis是个系统安全检查工具,针对Unix和Linux系统而设计, 通过执行一些安全检查发现系统安装的软件以及存在的配置问题。它能生成一份全面的加固建议列表，并由使用者灵活地自行决定实 施哪些加固措施。</p><h2 id="2-8-Nessus"><a href="#2-8-Nessus" class="headerlink" title="2.8 Nessus"></a>2.8 Nessus</h2><p>   Nessus是世界上最流行的漏洞扫描程序,提供完整的电脑漏洞 扫描服务，并随时更新其漏洞数据库，可同时在本机或远端上遥控， 进行系统的漏洞分析扫描。它完整支持SSL,可自定义功能插件。</p><h2 id="2-9-OpenVAS"><a href="#2-9-OpenVAS" class="headerlink" title="2.9 OpenVAS"></a>2.9 OpenVAS</h2><p>   OpenVAS是目前开源世界最重要的漏洞管理产品,它基于各种安 全行业的标准规范，广泛覆盖了已知的漏洞类型。它使用简单方便， 可以自动发现系统中绝大部分已知漏洞，无论对于渗透测试者还是 安全运维工程师，这都是一个不能缺少的强大工具。</p><h1 id="3-漏洞利用工具"><a href="#3-漏洞利用工具" class="headerlink" title="3 漏洞利用工具"></a>3 漏洞利用工具</h1><p>   发现了操作系统、网络和应用服务的漏洞，接下来怎么利用这些漏洞发起攻击呢? Kali提供了许多漏洞利用工具，这些工具有些功能强大，可以利用的漏洞类型很多，甚至可以定制，针对新的漏洞可通过添加脚本的方式扩展其功能，如Metasploit；有些工具则是针对特定的漏洞具有很好的效果。Kali系统提供的漏洞利用工具如下表所示</p><h2 id="3-1-Armitage"><a href="#3-1-Armitage" class="headerlink" title="3.1 Armitage"></a>3.1 Armitage</h2><p>   Armitage是一款Java写的Metasploit图形界面化的攻击软 件,可以用它结合Metasploit中已知的exploit来针对主机存在 的漏洞自动化攻击。通过命令行的方式使用Metasploit难度较高, 需要记忆的命令过多,而Armitage完美地解决了这一问题,用户 只需要简单地点击菜单，就可以实现对目标主机的安全测试和攻 击。Armitage良好的图形展示界面,使得攻击过程更加直观,用 户体验更好。因其操作的简单性,尤其适合Metasploit初学者对 目标系统进行安全测试和攻击。</p><h2 id="3-2-Backdoor-Factory"><a href="#3-2-Backdoor-Factory" class="headerlink" title="3.2  Backdoor Factory"></a>3.2  Backdoor Factory</h2><p>   Backdoor Factory是一款安全测试工具,可以轻松地生成 win32PE后门测试程序,可对可执行文件进行自动化的后门部署。</p><h2 id="3-3-BeEF"><a href="#3-3-BeEF" class="headerlink" title="3.3 BeEF"></a>3.3 BeEF</h2><p>   BeEF(Browser Exploitation Framework)是一款针对浏览 器的渗透测试工具。</p><h2 id="3-4-Metasploit-Framework"><a href="#3-4-Metasploit-Framework" class="headerlink" title="3.4 Metasploit Framework"></a>3.4 Metasploit Framework</h2><p>   Metasploit Framework简称MSF,是一个用Ruby语言写的渗 透测试框架,该框架集成了很多可用的渗透利用工具(Exploit Tools)。用户可以在这个框架下进行一 系列的渗透测试,利用现有的装备(Payload),如Meterpreter 等进一步拿取对方的Shell。Metasploit功能强大,几乎每一个 从事渗透测试的人都会接触到它，是渗透测试的利器。</p><h2 id="3-5-Exploitdb"><a href="#3-5-Exploitdb" class="headerlink" title="3.5  Exploitdb"></a>3.5  Exploitdb</h2><p>   Exploitdb(Exploit Database)是一个由“Offebnsive Security”提供的漏洞利用程序集的数据库,可以用于平时的参 考和使用。它存储了大量的漏洞利用程序，可以帮助安全研究者 和渗透测试工程师更好地进行安全测试工作。</p><h1 id="4-嗅探与欺骗工具"><a href="#4-嗅探与欺骗工具" class="headerlink" title="4 嗅探与欺骗工具"></a>4 嗅探与欺骗工具</h1><h2 id="4-1-Burp-Suite"><a href="#4-1-Burp-Suite" class="headerlink" title="4.1 Burp Suite"></a>4.1 Burp Suite</h2><p>   Burp Suite是Web应用程序测试的最佳工具之一,其功能强大,可 破解登陆表单，执行会话令牌等多种的随机性检查。以执行多种任务,如请求的拦截和修改,扫描web应用程序漏洞,以暴力破解登录表单，执行会话令牌等多种的随机性检查</p><h2 id="4-2-HexInject"><a href="#4-2-HexInject" class="headerlink" title="4.2 HexInject"></a>4.2 HexInject</h2><p>   HexInject是一款进行数据注入的工具,它可以直接向网络注入渗透 人员构造的数据包，也可以篡改网络传输的数据，为了避免修改带来的数 据验证问题，它默认对包进行校验，并重新计算包的大小，从而提高数据 的真实性。</p><h2 id="4-3-Inviteflood"><a href="#4-3-Inviteflood" class="headerlink" title="4.3  Inviteflood"></a>4.3  Inviteflood</h2><p>   Inviteflood攻击的目标是VoIP,它针对VoIP信令协议SIP中的 INVITE会话请求指令发起洪水攻击,被攻击者会瞬间接到大量呼叫请求, 导致类似电话占线的效果,严重时可令IP电话客户端程序崩溃。</p><h2 id="4-4-iSMTP"><a href="#4-4-iSMTP" class="headerlink" title="4.4 iSMTP"></a>4.4 iSMTP</h2><p>   iSMTP是一款SMTP用户枚举和测试工具。</p><h2 id="4-5-Mitmproxy"><a href="#4-5-Mitmproxy" class="headerlink" title="4.5 Mitmproxy"></a>4.5 Mitmproxy</h2><p>   Mitmproxy俗称中间人攻击的神器,是一款有篡改功能的http代理 工具,支持http通信与https通信,既可用于中间人攻击,也可用于 html抓包调试。mitmproxy共有五种代理模式:正向代理模式、反向代理 模式、上行代理模式、透明代理模式和socks5代理模式。</p><h2 id="4-6-SniffJoke"><a href="#4-6-SniffJoke" class="headerlink" title="4.6 SniffJoke"></a>4.6 SniffJoke</h2><p>   SniffJoke是一款网络防嗅探工具。在渗透测试中,通过网络嗅探, 可以获取网络通信主机的各种信息。SniffJoke可以防止嗅探,它能够自 动对用户的网络数据进行附加处理，如发包延时、修改部分包、注入无效 包，使得嗅探工具无法正确读取数据包，并且所有这些附加处理不会影响 数据接收方的处理。</p><h2 id="4-7-SSLstrip"><a href="#4-7-SSLstrip" class="headerlink" title="4.7 SSLstrip"></a>4.7 SSLstrip</h2><p>   SSLstrip也叫https降级攻击,攻击者拦截用户流量后,欺骗用 户与攻击者进行http通信,攻击者与服务器保持正常通信(http或 https),从而获取用户信息。</p><h2 id="4-8-WebScarab"><a href="#4-8-WebScarab" class="headerlink" title="4.8 WebScarab"></a>4.8 WebScarab</h2><p>   WebScarab是由开放式Web应用安全项目(OWASP)组开发的一个用 来分析使用HTTP和HTTPS协议的应用程序框架。WebScarab可以记录它 检测到的会话内容（请求和应答），并允许使用者通过多种形式来查看记 录。可以用它来调试程序中较难处理的漏洞，也可以帮助安全专家发现潜 在的程序漏洞。</p><h1 id="5-密码攻击工具"><a href="#5-密码攻击工具" class="headerlink" title="5 密码攻击工具"></a>5 密码攻击工具</h1><h2 id="5-1-BruteSpray"><a href="#5-1-BruteSpray" class="headerlink" title="5.1 BruteSpray"></a>5.1 BruteSpray</h2><p>   BruteSpray是一个基于Nmap扫描结果的端口爆破工具，它可以载入Nmap的扫描结果（gnmap&#x2F;XML文件），然后对我们指定的端口和IP进行枚举口令爆破，爆破过程可通过自动调用Medusa来进行。</p><h2 id="5-2-Cain-Abel"><a href="#5-2-Cain-Abel" class="headerlink" title="5.2  Cain&amp;Abel"></a>5.2  Cain&amp;Abel</h2><p>   Cain&amp;Abel 是由0xid.it开发的一个针对Microsoft操作系统的免费口令回复工具，号称穷人使用的LC，这是一款网络管理员必备的工具，它可以用来检测Windows，UNIX用户是否使用了不安全的密码。它的功能十分强大，可以进行网络嗅探、网络欺骗、破解加密口令、解码被打乱的口令、显示口令框、显示缓存口令和分析路由协议，甚至还可以监听内网中他人使用V0IP拨打电话。</p><h2 id="5-3-Crunch"><a href="#5-3-Crunch" class="headerlink" title="5.3 Crunch"></a>5.3 Crunch</h2><p>   Crunch是一款密码生成工具，可以按照指定的规则（用户可以指定字符集）生成密码字典。它可以产生所有有可能的组合和排列，其生成的字典字符序列可以输出到屏幕、文件或重定向到另一个程序中。</p><h2 id="5-4-Findmyhash"><a href="#5-4-Findmyhash" class="headerlink" title="5.4   Findmyhash"></a>5.4   Findmyhash</h2><p>   Findmyhash是一款可以破解哈希值的强大脚本，用python语言编写，如果用户希望破解一些难以理解的Hash值，使用Findmyhash脚本可以一键阅读出Hash值内的所有内容。</p><h2 id="5-5-Hash-Identifier"><a href="#5-5-Hash-Identifier" class="headerlink" title="5.5 Hash-Identifier"></a>5.5 Hash-Identifier</h2><p>   Hash-Identifier并不是Hash破解工具，而是用来判断Hash值所使用的加密方法的工具。</p><h2 id="5-6-Hydra"><a href="#5-6-Hydra" class="headerlink" title="5.6 Hydra"></a>5.6 Hydra</h2><p>   Hydra是由THC社区开发的一个在线快速破译密码工具，目的是为研究人员及安全顾问展示如何从远程侵入系统，其密码词库支持超过50种网络协议，包括Telnet、RDP、SSH、FTP、HTTP、HTTPS、SMB等等，还支持多种数据库的密码破译，Hydra-gtk是其图形用户界面版本。</p><h2 id="5-7-John-the-Ripper"><a href="#5-7-John-the-Ripper" class="headerlink" title="5.7 John the Ripper"></a>5.7 John the Ripper</h2><p>   John the Ripper是免费开源软件，是一个快速的密码破解工具，用于在已知密文的情况下尝试破解出明文的破解密码软件，支持目前大多数的加密算法，如DES、MD5等。它支持多种不同类型的系统架构，包括Unix，Linux，Windows，Dos模式、BeOs和openVMS，主要目的是破解不够牢固的Unix。Linux系统密码。</p><h2 id="5-8-Medusa"><a href="#5-8-Medusa" class="headerlink" title="5.8  Medusa"></a>5.8  Medusa</h2><p>   Medusa和Hydra一样是一款在线密码破解工具。优点是Medusa的稳定性较好，但Medusa支持的模块要比Hydra少很多，也不支持RDF服务协议。同时它的表单破解也存在一些问题。</p><h2 id="5-9-RainbowCrack"><a href="#5-9-RainbowCrack" class="headerlink" title="5.9 RainbowCrack"></a>5.9 RainbowCrack</h2><p>   RainbowCrack是一个使用内存时间交换技术加速口令破解过程的口令破解器。它使用了彩虹表也就是一张预先计算好的明文和散列值的对照表。通过预先花费时间创建这样的彩虹表，能够再以后破解口令时节约大量的时间</p><h2 id="5-10-Rtgen"><a href="#5-10-Rtgen" class="headerlink" title="5.10  Rtgen"></a>5.10  Rtgen</h2><p>   Rtgen工具用来生成彩虹表。彩虹表是一个庞大的，针对各种可能的字母组合预先计算好的哈希值的集合，不一定是针对MD5算法的，各种算法的都有，有了它可以快速地破解各种密码。越是复杂的密码，需要的彩虹表就越大，现在主流的彩虹表都是100G以上的。不同的加密方式要用不同的彩虹表。</p><h2 id="5-11-Samdump2"><a href="#5-11-Samdump2" class="headerlink" title="5.11 Samdump2"></a>5.11 Samdump2</h2><p>   Samdump2是一款破解Windows SAM 密码文件的工具。</p><h1 id="6-权限提升工具"><a href="#6-权限提升工具" class="headerlink" title="6 权限提升工具"></a>6 权限提升工具</h1><h2 id="6-1-Meterpreter"><a href="#6-1-Meterpreter" class="headerlink" title="6.1  Meterpreter"></a>6.1  Meterpreter</h2><p>   Meterpreter是一种后渗透工具，它属于一种在运行过程中可通过网络进行功能扩展的动态可扩展型Payload。这种是基于“内存DLL注入”理念实现的，它能够通过创建一个新进程并调用注入的DLL来让目标系统运行注入的DLL文件。在Meterpreter中可以执行Getsystem命令快速提权，Meterpreter会自己尝试用多种方法去提升权限，使得用户只需要运行一条指令就能获得System权限。</p><h2 id="6-2-SET"><a href="#6-2-SET" class="headerlink" title="6.2 SET"></a>6.2 SET</h2><p>   SET是社会工程包，是一个为社会工程设计的开放源码的渗透测试框架。它有许多自定义攻击向量，允许用户快速发起可信攻击。</p><h1 id="7-Web-应用工具"><a href="#7-Web-应用工具" class="headerlink" title="7 Web 应用工具"></a>7 Web 应用工具</h1><h2 id="7-1-Arachni"><a href="#7-1-Arachni" class="headerlink" title="7.1  Arachni"></a>7.1  Arachni</h2><p>   Arachni是一个多功能、模块化、高性能的Ruby框架,旨 在帮助渗透测试人员和管理员评估Web应用程序的安全性。同时 Arachni开源免费,可安装在Windows、Linux以及Mac系统上,并 且可导出评估报告。</p><h2 id="7-2-BlindElephant"><a href="#7-2-BlindElephant" class="headerlink" title="7.2  BlindElephant"></a>7.2  BlindElephant</h2><p>   BlindElephant是一款Web应用程序指纹识别工具。该工具可 以读取目标网站的特定静态文件,计算其对应的哈希值,然后和预 先计算出的哈希值做对比,从而判断目标网站的类型和版本号。目 前,该工具支持15种常见的Web应用程序的几百个版本。同时, 它还提供WordPress和Joomla的各种插件。该工具还允许用户自 已扩展，添加更多的版本支持。</p><h2 id="7-3-CutyCapt"><a href="#7-3-CutyCapt" class="headerlink" title="7.3 CutyCapt"></a>7.3 CutyCapt</h2><p>   CutyCapt是基于Qt实现的跨平台的将HTML网页转化成矢量 图形和位图图像格式的命令行工具(比如,SVG、PDF、PS、PNG、 JPEG、TIFF、GIF等)。</p><h2 id="7-4-DIRB"><a href="#7-4-DIRB" class="headerlink" title="7.4 DIRB"></a>7.4 DIRB</h2><p>   DIRB是一个专门用于爆破目录的工具。</p><h2 id="7-5-Nikto"><a href="#7-5-Nikto" class="headerlink" title="7.5 Nikto"></a>7.5 Nikto</h2><p>   Nikto是一款开源的(GPL)网页服务器扫描器,它可以对网页 服务器进行全面的多种扫描,包含超过3300种有潜在危险的文件&#x2F; CGIs、超过625种服务器版本、超过230种特定服务器问题。</p><h2 id="7-6-Paros-Proxy"><a href="#7-6-Paros-Proxy" class="headerlink" title="7.6   Paros Proxy"></a>7.6   Paros Proxy</h2><p>   Paros Proxy是一个对Web应用程序的漏洞进行评估的代理程 序,它是一个基于Java的Web代理程序,可以评估Web应用程序 的漏洞。它支持动态地编辑&#x2F;查看HTTP&#x2F;HTTPS,从而改变cookies 和表单字段等项目。它包括一个Web通信记录程序、Web圈套程序、 hash计算器,还有一个可以测试常见的Web应用程序攻击的扫描器。该工具检查漏洞形式包括:SQL注入、跨站点脚本攻击、目录遍历等。</p><h2 id="7-7-ProxyStrike"><a href="#7-7-ProxyStrike" class="headerlink" title="7.7  ProxyStrike"></a>7.7  ProxyStrike</h2><p>   ProxyStrike是一款用于web漏洞扫描的工具，需要配置代理使用，带有爬虫模块、请求报告、日志、配置等功能模块</p><h2 id="7-8-Vega"><a href="#7-8-Vega" class="headerlink" title="7.8  Vega"></a>7.8  Vega</h2><p>   Vega是一个开放源代码的Word应用程序安全测试平台, Vega能够帮助验证SQL注入、跨站脚本、敏感信息泄露和其他一些安全漏洞。Vega使用Java编写,有GUI,可以在Linux、OS X和 Windows下运行。</p><h2 id="7-9-Webshag"><a href="#7-9-Webshag" class="headerlink" title="7.9 Webshag"></a>7.9 Webshag</h2><p>   Webshag是一个对Web服务器进行安全审计的跨平台多线程工具。Webshag会收集那些通常对Web服务器有用的功能,比如 Webshag是一个用于对Web服务器进行安全审计的跨平台多线 端口扫描、URL扫描和文件模糊测试。可以通过代理和HTTP身份认 证(基于认证或摘要认证),以HTTP或HTTPS的方式扫描Web服务器。此外Webshag可以凭借IDS规避能力,使请求之间的相关性变得更 复杂。</p><h2 id="7-10-WebSploit"><a href="#7-10-WebSploit" class="headerlink" title="7.10 WebSploit"></a>7.10 WebSploit</h2><p>   WebSploit是一个开源项目,主要用于远程扫描和分析系统漏 洞。使用它可以非常容易和快速发现系统中存在的问题，并用于深 入分析。</p><h2 id="7-11-Whatweb"><a href="#7-11-Whatweb" class="headerlink" title="7.11 Whatweb"></a>7.11 Whatweb</h2><p>   Whatweb是一个基于Ruby语言的开源网站指纹识别软件,正如 它的名字一样,Whatweb能够识别各种关于网站的详细信息,包括: CMS类型、博客平台、中间件、Web框架模块、网站服务器、脚本类型、 JavaScript库、IP、cookie等等。</p><h1 id="8-无线攻击工具"><a href="#8-无线攻击工具" class="headerlink" title="8 无线攻击工具"></a>8 无线攻击工具</h1><h2 id="8-1-Aircrack-ng"><a href="#8-1-Aircrack-ng" class="headerlink" title="8.1 Aircrack-ng"></a>8.1 Aircrack-ng</h2><p>   Aircrack-ng是一个与802.11标准的无线网络分析有关的 安全软件，主要功能有：虚拟管道创建、网络侦测、数据包嗅 探、WEP和WPA&#x2F;WPA2-PSK破解、essid密码列表的保存和管理。Aircrack-ng可以工作在任何支持监听模式的无线网卡上并嗅探 802.11b,802.11b,802.11g的数据。该程序可运行在Linux和 Windows上。</p><h2 id="8-2-Arpspoof"><a href="#8-2-Arpspoof" class="headerlink" title="8.2 Arpspoof"></a>8.2 Arpspoof</h2><p>   Arpspoof是一款专业的ARP断网攻击软件,能够直接欺骗网 关,使得通过网关访问网络的电脑全被欺骗攻击,通过ARP欺骗 达到中间人嗅探和捕获网络数据包的目的，并替换传输中的数据， 方便用户开启ARP断网攻击,抢占网速。</p><h2 id="8-3-Easy-Creds"><a href="#8-3-Easy-Creds" class="headerlink" title="8.3 Easy-Creds"></a>8.3 Easy-Creds</h2><p>   Easy-Creds是一款欺骗嗅探为主的攻击脚本工具,它具备 ARP毒化、DNS毒化等一些嗅探攻击模式。它最亮的地方就是它 的fake AP(欺骗访问点)功能。它比一般自行搭建的fake AP 要稳定得多,而且里面还包含了针对802.1x的攻击模式。</p><h2 id="8-4-Gerix-Wifi-Cracker"><a href="#8-4-Gerix-Wifi-Cracker" class="headerlink" title="8.4 Gerix Wifi Cracker"></a>8.4 Gerix Wifi Cracker</h2><p>   Gerix Wifi Cracker是一个aircrack图形用户界面的无线 网络破解工具，可破解无线网络密码。</p><h2 id="8-5-Kismet"><a href="#8-5-Kismet" class="headerlink" title="8.5 Kismet"></a>8.5 Kismet</h2><p>   Kismet是一款802.11二层无线网络探测器、嗅探器和入侵 检测系统，使用该工具可以检测周围的无线信号，并查看所有可 用的无线接入点,并能嗅出802.11a&#x2F;b&#x2F;g&#x2F;n的流量。</p><h2 id="8-6-Reaver"><a href="#8-6-Reaver" class="headerlink" title="8.6 Reaver"></a>8.6 Reaver</h2><p>   Reaver是一款针对开启Wi-Fi安全防护设定(Wi-Fi Protected Setup,WPS)服务的无线网络的破解工具。</p><h2 id="8-7-Wifte"><a href="#8-7-Wifte" class="headerlink" title="8.7  Wifte"></a>8.7  Wifte</h2><p>   Wifte是一款使用Aircrack-ng工具集来破解无线网络的带 图形用户界面的工具,是一款自动化WEP、WPA以及WPS破解工具, 特点是可以同时攻击多个采用WEP和WPA加密的网络。</p><h1 id="9-维持访问工具"><a href="#9-维持访问工具" class="headerlink" title="9 维持访问工具"></a>9 维持访问工具</h1><h2 id="9-1-Cryptcat"><a href="#9-1-Cryptcat" class="headerlink" title="9.1  Cryptcat"></a>9.1  Cryptcat</h2><p>   Cryptcat是网络工具Netcat的加密版本。Cryptcat支持TCP、UDP两种 网络协议。它可以在两个计算机之间建立指定的连接，并使用特定的密钥对 传输数据进行加密。为了提高加密效果，该工具允许用户在每次连接时使用 自定义的密钥，从而保证数据的安全性。</p><h2 id="9-2-Cymothoa"><a href="#9-2-Cymothoa" class="headerlink" title="9.2  Cymothoa"></a>9.2  Cymothoa</h2><p>   Cymothoa是一款可以将ShellCode注入现有进程(插入进程)的后门工具。借助这种注入手段,它能够把ShellCode伪装成常规程序。它所注入的后门 程序能够与被注入的程序共存,以避免被管理或维护人员怀疑。将ShellCode 注入其他进程，还有另外一个优势就是：即使目标系统的安全防护工具能够 检验可执行程序的完整性，只要它不检查内存，就不能发现后门程序的进程。</p><h2 id="9-3-Intersect"><a href="#9-3-Intersect" class="headerlink" title="9.3  Intersect"></a>9.3  Intersect</h2><p>   Intersect是一款适合在漏洞利用以后使用的能够自动完成多种后期任 务的程序。它能够自动收集密码文件、赋值SSH密钥、收集网络信息,并能 识别杀毒软件和防火墙程序。若要它自动执行后期任务，用户需要创建自己 的脚本文件,脚本中指定需要执行的各种功能。对于Inetersect来说,每个 功能都有对应的执行模块。</p><h2 id="9-4-NetCat"><a href="#9-4-NetCat" class="headerlink" title="9.4 NetCat"></a>9.4 NetCat</h2><p>   NetCat是一个非常简单的Unix工具,可以读、写TCP或UDP网络连接 (Network Connection)。它被设计成一个可靠的后端(Back-End)工具, 能被其他的程序或脚本直接地或容易地驱动。同时，它又是一个功能丰富的 网络调试和开发工具，因为它可以建立用户可能用到的几乎任何类型的连接， 以及一些非常有意思的内建功能。</p><h2 id="9-5-Weevely"><a href="#9-5-Weevely" class="headerlink" title="9.5 Weevely"></a>9.5 Weevely</h2><p>   Weevely是一款针对PHP的webshell的自由软件,可用于模拟一个类似 于Telnet的连接shell, Weevely通常用于Web程序的漏洞利用,隐藏后门 或者使用类似Telnet的方式来代替Web页面式的管理, Weevely生成的服 务器端php代码是经过了base64编码的,所以可以骗过主流的杀毒软件和 IDS,上传服务器端代码后通常可以通过Weevely直接运行。</p><h1 id="10-取证工具"><a href="#10-取证工具" class="headerlink" title="10 取证工具"></a>10 取证工具</h1><h2 id="10-1-Bulk-extractor"><a href="#10-1-Bulk-extractor" class="headerlink" title="10.1 Bulk _ extractor"></a>10.1 Bulk _ extractor</h2><p>   Bulk _ extractor是从数字证据文件中提取诸如电子邮件地址、信 用卡号、URL和其他类型的信息的功能的程序。它是一个有用的取证 调查工具，可以用于许多任务，如恶意软件和入侵调查、身份调查和 网络调查，以及图像分析和密码破解。</p><h2 id="10-2-Capstone"><a href="#10-2-Capstone" class="headerlink" title="10.2 Capstone"></a>10.2 Capstone</h2><p>   Capstone是一款优秀的反汇编框架,支持多种CPU架构,支持多 个平台，提供反汇编指令的语义详情，用一个授权许可便可以为所有 重要编程语言提供捆包等。</p><h2 id="10-3-Dumpzilla"><a href="#10-3-Dumpzilla" class="headerlink" title="10.3  Dumpzilla"></a>10.3  Dumpzilla</h2><p>   Dumpzilla是用Python3开发的,目的是提取Firefox, Iceweasel和Seamonkey浏览器的相关信息进行分析。它在Unix和 Windows 32&#x2F;64位系统下工作,采用命令行界面,所以信息可以通过 管道重定向工具(如grep, awk, cut, sed)进行转储。</p><h2 id="10-4-Galeta"><a href="#10-4-Galeta" class="headerlink" title="10.4 Galeta"></a>10.4 Galeta</h2><p>   Galeta是一个取证工具,用于检查微软公司Internet Explorer 生产的Cookie文件的内容。它解析文件并输出可以在电子表格中加载 的字段。</p><h2 id="10-5-Peepdf"><a href="#10-5-Peepdf" class="headerlink" title="10.5  Peepdf"></a>10.5  Peepdf</h2><p>   Peepdf是一个用Python开发的、集成了多个组件的、用于检测 和分析PDF文件是否有害的取证工具。</p><h2 id="10-6-RegRipper"><a href="#10-6-RegRipper" class="headerlink" title="10.6 RegRipper"></a>10.6 RegRipper</h2><p>   RegRipper是一款用来对Windows操作系统的注册表进行取证的工具。</p><h2 id="10-7-Volatility"><a href="#10-7-Volatility" class="headerlink" title="10.7 Volatility"></a>10.7 Volatility</h2><p>   Volatility是开源的Windows, linux，Mac, Android的内存取 证分析工具、由Python编写成,命令行操作,支持各种操作系统。</p><h1 id="11-逆向工程工具"><a href="#11-逆向工程工具" class="headerlink" title="11 逆向工程工具"></a>11 逆向工程工具</h1><h2 id="11-1-DiStorm3"><a href="#11-1-DiStorm3" class="headerlink" title="11.1 DiStorm3"></a>11.1 DiStorm3</h2><p>   DiStorm3是Kali Linux自带的一款轻量级、容易使用的反汇编 引擎。它可以反汇编生成16位、32位和64位指令。它支持的指令 集包括FPU、MMX、SSE、SSE2、SSE3、SSSE3、SSE4、x86-64、VMX、 AMDs、SVM等。虽然diStorm3采用C语言编写,但可以被Python、 Ruby、Java快速封装。这样,用户可以使用Python、Rudy等脚本语言编写脚本，并引入diStorm33，从而定制自己的反汇编工具。</p><h2 id="11-2-Edb-debugger"><a href="#11-2-Edb-debugger" class="headerlink" title="11.2    Edb-debugger"></a>11.2    Edb-debugger</h2><p>   Edb-debugger是一个跨平台的x86&#x2F;x86-64调试器。它受到 Ollydbg的启发,但是其目标是在x86和x86-64以及多个操作系 统上运行。Linux是目前edb-debugger唯一官方支持的平台,但 FreeBSD,OpenBSD,OSX和Windows端口正在进行不同程度的功能实现。</p><h2 id="11-3-Flasm"><a href="#11-3-Flasm" class="headerlink" title="11.3 Flasm"></a>11.3 Flasm</h2><p>   Flasm可以对Flash的SWF文件进行拆解,包括所有的时间表和 事件。通过反汇编,用户可以了解Flash编译器的工作原理,从而提 高用户的ActionScript技能。用户也可以手动对反汇编代码进行优 化,或者根据需要调整代码,然后利用Flasm将用户的更改应用于原 SWF,替换原始操作</p><h2 id="11-4-JavaSnoop"><a href="#11-4-JavaSnoop" class="headerlink" title="11.4  JavaSnoop"></a>11.4  JavaSnoop</h2><p>   JavaSnoop是一个java应用程序安全测试工具，它允许已拦截的方法,篡改数据和hack运行在计算机上的java应用程序。通常在没 JavaSnoop是一个java应用程序安全测试工具,它允许以拦截的 有源代码的情况下,测试java客户端的安全性是不可预知的。在有源 代码的情况下,可以运行一个简单的java程序,并在远程附加一个调 试器来调试它,单步运行,根据需要改变变量,但对于一个applet来 说要想做到这一点是有点困难的。有时，可能需要修改客户端和服务 器之间的通信，一般的做法是在客户端配置一个代理，在代理上修改 数据。问题的关键是，通信的数据通常不是明文的，可能使用了自定 义的协议、序列化的对象、加密的数据或者多种方式混合应用。这样 要想修改通信过程中的数据是比较困难的。JavaSnoop试图解决这些 问题，它可直接附加到一个运行中的进程，类似于调试器，然后，篡 改方法调用、运行自定义代码或者对系统进行监视。</p><h2 id="11-5-011yDbg"><a href="#11-5-011yDbg" class="headerlink" title="11.5 011yDbg"></a>11.5 011yDbg</h2><p>   011yDbg是一个新的动态追踪工具,将IDA与SoftICE结合起来, Ring 3级调试器,非常容易上手,已代替SoftICE成为当今最为流行 的调试解密工具。同时还支持插件扩展功能，是目前最强大的调试工具。</p><p>   Valgrind是一款用于内存调试、内存泄漏检测以及性能分析的软 件开发工具。</p><h2 id="11-6-压力测试工具"><a href="#11-6-压力测试工具" class="headerlink" title="11.6 压力测试工具"></a>11.6 压力测试工具</h2><h2 id="11-7-DHCPig"><a href="#11-7-DHCPig" class="headerlink" title="11.7 DHCPig"></a>11.7 DHCPig</h2><p>   DHCPig可以发起一个高级的DHCP耗尽攻击。它将消耗局域网内的所 有IP地址以及阻止新客户端获取IP,同时它也防止旧客户端释放IP地址。另外,它会发送无效的ARP去把所有的Windows主机震下线。</p><h2 id="11-8-FunkLoad"><a href="#11-8-FunkLoad" class="headerlink" title="11.8  FunkLoad"></a>11.8  FunkLoad</h2><p>   FunkLoad是一个功能和负载的Web测试仪,主要用于Web项目,对网 站项目进行功能测试、性能测试、负载测试（如音量的测试或寿命测试） 和压力测试。</p><h2 id="11-9-IAX"><a href="#11-9-IAX" class="headerlink" title="11.9  IAX"></a>11.9  IAX</h2><p>   IAX是Inter-Asterisk eXchange的缩写,也就是Asterisk内部交换 协议。iaxflood则是利用IAX设计缺陷而发起洪水式攻击的工具。</p><h2 id="11-10-Inundator"><a href="#11-10-Inundator" class="headerlink" title="11.10 Inundator"></a>11.10 Inundator</h2><p>   Inundator是一个支持多目标的、多线程的、队列驱动的、匿名的、 误用入侵检测系统。</p><h2 id="11-11-MDK3"><a href="#11-11-MDK3" class="headerlink" title="11.11   MDK3"></a>11.11   MDK3</h2><p>   MDK3是一款无线DOS攻击测试工具,能够发起Beacon Flood、 Authentication DoS、Deauthentication&#x2F;Disassociation Amok等模式的 攻击,另外它还具有针对隐藏ESSID的暴力探测模式、802.1X渗透测试、 WIDS干扰等功能。</p><h2 id="11-12-Rtpflood"><a href="#11-12-Rtpflood" class="headerlink" title="11.12 Rtpflood"></a>11.12 Rtpflood</h2><p>   Rtpflood可以洪水攻击RTP通话设备,实现拒绝服务的效果。</p><h2 id="11-13-Inviteflood"><a href="#11-13-Inviteflood" class="headerlink" title="11.13 Inviteflood"></a>11.13 Inviteflood</h2><p>   Inviteflood通过TCP&#x2F;UDP进行泛洪攻击的SIP&#x2F;SDP会话,该工具可 以在本机产生大量的流量，因为需要在本地读取数据进行对外发送。所以 在流量监控时可能会产生40M&#x2F;s的速度。</p><h2 id="11-14-SlowHTTPTest"><a href="#11-14-SlowHTTPTest" class="headerlink" title="11.14 SlowHTTPTest"></a>11.14 SlowHTTPTest</h2><p>   SlowHTTPTest是依赖HTTP协议的慢速攻击DoS攻击工具,设计的基 本原理是服务器在请求完全接收后才会进行处理，如果客户端的发送速度 缓慢或者发送不完整，服务端为其保留连接资源池占用，大量此类请求并 发将导致DoS。</p><h2 id="11-15-THC-SSL-DOS"><a href="#11-15-THC-SSL-DOS" class="headerlink" title="11.15 THC-SSL-DOS"></a>11.15 THC-SSL-DOS</h2><p>   THC-SSL-DOS是一款针对SSL的压力测试工具。该工具默认会同服务 器建立400个SSL连接,并且快速进行重新协商Renegotiations,以达到 大量消耗服务器CPU资源的目的。该工具目前只针对开启重新协商功能的 服务器，所以只要关闭该功能，就可以抵御该工具的攻击。</p><h1 id="12-报告工具"><a href="#12-报告工具" class="headerlink" title="12 报告工具"></a>12 报告工具</h1><h2 id="12-1-CaseFile"><a href="#12-1-CaseFile" class="headerlink" title="12.1 CaseFile"></a>12.1 CaseFile</h2><p>   CaseFile是Maltego的姊妹工具,功能非常类似于Maltego。CaseFile主要针对数据进行离线分析,缺少Maltego的数据采集功能。它可以导入各类数据,包括Maltego导出的数据。用户可以为信息添 加连接线、标签和注释,标记数据的关系。CaseFile以图形化的方式 展现数据，方便分析人员找出隐含的数据关系。</p><h2 id="12-2-CherryTree"><a href="#12-2-CherryTree" class="headerlink" title="12.2 CherryTree"></a>12.2 CherryTree</h2><p>   CherryTree支持富文本编辑和代码高亮,支持Linux和Windows平台。数据采用 CherryTree是一个支持无限层级分类的笔记软件,由Python编与, sqlite或XML存储,支持密码保护。支持从NoteCase、KeepNote、Knowit、Tomboy、TuxCards、Treepad、Leo等笔记软件导入数据。</p><h2 id="12-3-Dos2unix"><a href="#12-3-Dos2unix" class="headerlink" title="12.3 Dos2unix"></a>12.3 Dos2unix</h2><p>   Dos2unix命令用来将DOS格式的文本文件转换成UNIX格式的文 本。</p><h2 id="12-4-Dradis"><a href="#12-4-Dradis" class="headerlink" title="12.4 Dradis"></a>12.4 Dradis</h2><p>   Dradis框架是一个开源的、用Ruby开发的协作和报告平台。可生成渗透测试报告，内容包括所提供的服务、使用的方法、发现的结 果和建议。</p><h2 id="12-5-MagicTree"><a href="#12-5-MagicTree" class="headerlink" title="12.5  MagicTree"></a>12.5  MagicTree</h2><p>   MagicTree是一个面向渗透测试人员的工具,可以帮助用户轻松 直接地进行数据合并、查询、外部命令执行和报告生成，所有的数据 都会以树形结构存储，非常方便。</p><h2 id="12-6-Metagoofil"><a href="#12-6-Metagoofil" class="headerlink" title="12.6 Metagoofil"></a>12.6 Metagoofil</h2><p>   Metagoofil是一款利用Google收集信息的工具,目前支持的文件类型有Word、PPT、Excel和PDF,结果可生成HTML报告文件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-信息收集&quot;&gt;&lt;a href=&quot;#1-信息收集&quot; class=&quot;headerlink&quot; title=&quot;1 信息收集&quot;&gt;&lt;/a&gt;1 信息收集&lt;/h1&gt;&lt;h2 id=&quot;1-1-Amap&quot;&gt;&lt;a href=&quot;#1-1-Amap&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/kaliTool/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/tags/kaliTool/"/>
    
  </entry>
  
  <entry>
    <title>密评测试常用命令</title>
    <link href="http://suzi007.github.io/2024/04/17/%E5%AF%86%E8%AF%84%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://suzi007.github.io/2024/04/17/%E5%AF%86%E8%AF%84%E6%B5%8B%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2024-04-17T07:11:11.000Z</published>
    <updated>2025-01-03T02:27:50.458Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Linux"><a href="#1-Linux" class="headerlink" title="1 Linux"></a>1 Linux</h1><table><thead><tr><th>测评查看项</th><th>测评命令</th></tr></thead><tbody><tr><td>版本</td><td>more &#x2F;etc&#x2F;redhat-release</td></tr><tr><td>用户</td><td>more &#x2F;etc&#x2F;shadow</td></tr><tr><td>密码复杂度</td><td>more &#x2F;etc&#x2F;pam.d&#x2F;system-auth</td></tr><tr><td>查看密码更换周期</td><td>more &#x2F;etc&#x2F;login.defs</td></tr><tr><td>超时自动退出</td><td>more &#x2F;etc&#x2F;profile</td></tr><tr><td>查看所有端口</td><td>netstat -ntlp</td></tr><tr><td>查看备份时间</td><td>more &#x2F;etc&#x2F;crontab</td></tr><tr><td>审计是否开启</td><td>systemctl status auditd.service</td></tr><tr><td>日志是否运行</td><td>systemctl status rsyslog</td></tr><tr><td>sshd 是否运行</td><td>systemctl status sshd</td></tr><tr><td>查看 Linux 防火墙规则</td><td>iptables -L</td></tr><tr><td>看 IP 地址</td><td>ifconfig</td></tr><tr><td>看时间</td><td>date</td></tr><tr><td>查看日志</td><td>tail -20 &#x2F;var&#x2F;log&#x2F;audit&#x2F;audit.log</td></tr><tr><td>查看当前系统版本</td><td>uname -a</td></tr><tr><td>查看已安装的包</td><td>yum list installed</td></tr><tr><td>是否安装最新的补丁</td><td>rpm -qa grep patch</td></tr></tbody></table><h1 id="2-Windows"><a href="#2-Windows" class="headerlink" title="2 Windows"></a>2 Windows</h1><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>测评查看项</td><td>测评命令</td><td>备注</td></tr><tr><td>用户账户</td><td>netplwiz</td><td>control userpasswords 2</td></tr><tr><td>用户和用户组</td><td>lusrmgr.msc</td><td></td></tr><tr><td>账户策略</td><td>secpol.msc</td><td></td></tr><tr><td>远程管理</td><td>gpedit.msc；mstsc</td><td><strong>gpedit.msc</strong><br><br>–》管理模板–》Windows 组件–》远程桌面服务–》远程桌面会话主机–》安全</td></tr><tr><td>日志查看</td><td>eventvwr.msc</td><td></td></tr><tr><td>查看最小安装</td><td>dcomcnfg</td><td><strong>dcomcnfg</strong><br><br>-》组件服务-》计算机-》我的电脑</td></tr><tr><td>多余的组件</td><td>appwiz.cpl</td><td></td></tr><tr><td>系统服务</td><td>services.msc</td><td></td></tr><tr><td>查看共享</td><td>net share</td><td></td></tr><tr><td>查看端口</td><td>netstat -an</td><td></td></tr><tr><td>查看防火墙</td><td>firewall.cpl</td><td></td></tr><tr><td></td><td>ipconfig &#x2F;release</td><td>→ 要求服务器释放曾经记录的已经分配出去的 IP 地址</td></tr><tr><td></td><td>ipconfig &#x2F;renew</td><td>→ 终端电脑再次重新获取一次 IP 地址</td></tr></tbody></table><h1 id="3-网络设备"><a href="#3-网络设备" class="headerlink" title="3 网络设备"></a>3 网络设备</h1><h2 id="3-1-华为交换机"><a href="#3-1-华为交换机" class="headerlink" title="3.1 华为交换机"></a>3.1 华为交换机</h2><table><thead><tr><th>测评查看项</th><th>测评命令</th></tr></thead><tbody><tr><td>版本</td><td>dis version</td></tr><tr><td>密码复杂度</td><td>dis password-control</td></tr><tr><td>用户</td><td>dis local-user</td></tr><tr><td>登录失败，密码周期</td><td>dis local-user username admin</td></tr><tr><td>登录超时时间</td><td>dis aaa configuration</td></tr><tr><td>查看日志</td><td>dis  logbuffer</td></tr><tr><td>查看警告</td><td>dis  trapbuffer</td></tr><tr><td>查看配置</td><td>dis cur</td></tr><tr><td>查看端口</td><td>dis interface brief</td></tr><tr><td>查看 telnet 是否开启</td><td>dis telnet server status</td></tr><tr><td>查看 ip</td><td>dis ip interface</td></tr><tr><td>查看 acl 限制</td><td>dis  acl all</td></tr><tr><td>查看冗余</td><td>dis  irf</td></tr><tr><td>查看 cpu</td><td>dis cpu-usage</td></tr><tr><td>查看内存</td><td>dis  memory-usage</td></tr><tr><td>查看补丁</td><td>dis path-infomation</td></tr><tr><td>查看审计是否开启</td><td>dis  info</td></tr><tr><td>查看 ssh</td><td>dis ssh server-info</td></tr></tbody></table><h2 id="3-2-华三交换机"><a href="#3-2-华三交换机" class="headerlink" title="3.2 华三交换机"></a>3.2 华三交换机</h2><table><thead><tr><th>查看测评项</th><th>测评命令</th></tr></thead><tbody><tr><td>版本</td><td>dis version</td></tr><tr><td>查看 Log buffer、Log host 日志是否开启</td><td>dis info-center</td></tr><tr><td>查看日志</td><td>dis logbuffer</td></tr><tr><td>查看 cpu</td><td>dis cpu</td></tr><tr><td>查看内存</td><td>dis memory</td></tr><tr><td>查看端口</td><td>dis interface brief</td></tr><tr><td>查看 acl 限制</td><td>dis acl all</td></tr><tr><td>密码复杂度</td><td>dis password-control</td></tr></tbody></table><h2 id="3-3-思科交换机"><a href="#3-3-思科交换机" class="headerlink" title="3.3 思科交换机"></a>3.3 思科交换机</h2><table><thead><tr><th>查看测评项</th><th>测评命令</th><th>备注</th></tr></thead><tbody><tr><td>全局模式</td><td>configure terminal</td><td></td></tr><tr><td>特权模式</td><td>enable</td><td></td></tr><tr><td>查看 AAA</td><td>show aaa all</td><td></td></tr><tr><td>查看密码复杂度要求</td><td>show password-strength</td><td></td></tr><tr><td>查看登录失败处理配置</td><td>show login</td><td></td></tr><tr><td>查看登录失败策略</td><td>show login failures</td><td></td></tr><tr><td>登录超时</td><td>show running-config</td><td>include timeout</td></tr><tr><td>查看当前账户</td><td>show running-config</td><td>include username</td></tr><tr><td>查看用户名和权限</td><td>show running-config</td><td>include usename admin</td></tr><tr><td>查看日志</td><td>show logging last</td><td></td></tr><tr><td>查看 syslog</td><td>show logging server</td><td></td></tr><tr><td>查看 AAA</td><td>show aaa accounting</td><td></td></tr><tr><td>查看自动配置</td><td>show schedule job-list</td><td></td></tr><tr><td>查看版本</td><td>show version</td><td></td></tr></tbody></table><h1 id="4-数据库"><a href="#4-数据库" class="headerlink" title="4 数据库"></a>4 数据库</h1><h2 id="4-1-MySQL"><a href="#4-1-MySQL" class="headerlink" title="4.1 MySQL"></a>4.1 MySQL</h2><table><thead><tr><th>测评查看项</th><th>测评命令</th></tr></thead><tbody><tr><td>数据库版本</td><td>select version();</td></tr><tr><td>进入数据库</td><td>mysql -u root -p</td></tr><tr><td>查看设置用户</td><td>select * from mysql.user</td></tr><tr><td>查看设置用户</td><td>select host,user,plugin from mysql.user</td></tr><tr><td>检查是否存在空口令</td><td>select host,user,password,plugin from mysql.user;</td></tr><tr><td></td><td>select host,user,authentication_string,plugin from mysql.user;</td></tr><tr><td>检查密码复杂度</td><td>show variables like ‘validate_password%’;</td></tr><tr><td>检查口令定期更换</td><td>select host,user,password_lifetime from mysql.user</td></tr><tr><td>检查是否安装登录失败处理模块</td><td>select * from information_schema.Plugins where plugin_name&#x3D;‘connection_control’;</td></tr><tr><td>检查配置登录失败处理参数</td><td>show variables like ‘connction_control’;</td></tr><tr><td>检查连接超时</td><td>show variables like ‘%timeout’;</td></tr><tr><td>检查日志模块状态</td><td>show variables like ‘general_log%’;</td></tr><tr><td>检查是否并开启 MySQL Enterprise Audit 模块</td><td>select * from INFORMATION_SCHEMA.PLUGINS WHERE PLUGIN_NAME&#x3D;‘audit_log’;</td></tr><tr><td>检查是否开启 SSL 通信</td><td>show variables like ‘require_secure_transport’;</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Linux&quot;&gt;&lt;a href=&quot;#1-Linux&quot; class=&quot;headerlink&quot; title=&quot;1 Linux&quot;&gt;&lt;/a&gt;1 Linux&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;测评查看项&lt;/th&gt;
&lt;th&gt;测评命令&lt;/th&gt;
&lt;/t</summary>
      
    
    
    
    <category term="商用密码" scheme="http://suzi007.github.io/categories/%E5%95%86%E7%94%A8%E5%AF%86%E7%A0%81/"/>
    
    <category term="测评工具" scheme="http://suzi007.github.io/categories/%E5%95%86%E7%94%A8%E5%AF%86%E7%A0%81/%E6%B5%8B%E8%AF%84%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="密码测评" scheme="http://suzi007.github.io/tags/%E5%AF%86%E7%A0%81%E6%B5%8B%E8%AF%84/"/>
    
    <category term="测评工具" scheme="http://suzi007.github.io/tags/%E6%B5%8B%E8%AF%84%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>AST还原</title>
    <link href="http://suzi007.github.io/2024/04/17/AST%E8%BF%98%E5%8E%9F/"/>
    <id>http://suzi007.github.io/2024/04/17/AST%E8%BF%98%E5%8E%9F/</id>
    <published>2024-04-17T07:11:11.000Z</published>
    <updated>2025-01-03T02:39:13.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-学习网站"><a href="#1-学习网站" class="headerlink" title="1 学习网站"></a>1 学习网站</h1><ul><li><a href="https://blogz.gitee.io/ast/">AST explorer 国内镜像</a></li><li><a href="https://astexplorer.net/">AST explorer</a> ，一个在线解析 AST 的网站。</li><li><a href="https://obfuscator.io/">ob 混淆工具官网</a>，可以用它的 demo 检测下自己的 AST 水准</li><li><a href="http://tool.yuanrenxue.com/">猿人学爬虫工具合集</a></li></ul><h1 id="2-基本组件"><a href="#2-基本组件" class="headerlink" title="2 基本组件"></a>2 基本组件</h1><h2 id="2-1-parser"><a href="#2-1-parser" class="headerlink" title="2.1 parser"></a>2.1 parser</h2><blockquote><p>描述：将 js 代码转换为抽象语法树<br>用法：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parse = <span class="built_in">require</span>(<span class="string">&quot;@babel/parser&quot;</span>).<span class="property">parse</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> traverse = <span class="built_in">require</span>(<span class="string">&quot;@babel/traverse&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-2-generator"><a href="#2-2-generator" class="headerlink" title="2.2 generator"></a>2.2 generator</h2><blockquote><p>描述：将抽象语法树还原为 JS 代码<br>用法：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generate = <span class="built_in">require</span>(<span class="string">&quot;@babel/generator&quot;</span>).<span class="property">default</span></span><br><span class="line"><span class="title function_">generate</span>(ast).<span class="property">code</span></span><br></pre></td></tr></table></figure><h2 id="2-3-traverse"><a href="#2-3-traverse" class="headerlink" title="2.3 traverse"></a>2.3 traverse</h2><blockquote><p>描述：遍历 node 节点<br>用法：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast,&#123;</span><br><span class="line"><span class="title class_">StringInditify</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//方式二 enter 和 exit的区别</span></span><br><span class="line"><span class="title function_">traverse</span>(ast,&#123;</span><br><span class="line"><span class="title class_">StringInditify</span>: &#123;</span><br><span class="line"><span class="attr">exit</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="3-基本属性"><a href="#3-基本属性" class="headerlink" title="3 基本属性"></a>3 基本属性</h1><h2 id="3-1-Path"><a href="#3-1-Path" class="headerlink" title="3.1 Path"></a>3.1 Path</h2><p>属性：</p><ul><li>path.replaceWith 把这个节点替换成另外一个节点， 接收参数为 node</li><li>path.node获取当前路径对应的节点。</li><li>path.parent获取当前路径对应节点的父节点。</li><li>path.parentPath获取当前路径对应节点的父路径。</li><li>path.scope表示当前 path 下的作用域，这个也是写插件经常会用到的。</li><li>path.container用于获取当前 path 下的所有兄弟节点(包括自身)。</li><li>path.type获取当前 path 的节点类型。</li><li>path.key获取当前 path 的 key 值，key 通常用于 path.get 函数。</li></ul><p>函数：</p><ul><li>path.get(key)获取当前路径下指定属性名（key）对应的子路径。例如，path.get(“body”) 获取当前路径下名为 “body” 的子路径。</li><li>path.getSibling(index)获取当前路径对应节点的兄弟节点的路径。通过指定索引（index）可以获取相应的兄弟路径。</li><li>path.getFunctionParent()获取当前路径对应节点的最近的函数父节点的路径。</li><li>path.getPrevSibling()获取当前 path 的前一个兄弟节点，返回的是 path 类型。</li><li>path.getAllPrevSiblings()获取当前 path 的所有前兄弟节点，返回的是 Array 类型，其元素都是 path 类型。</li><li>path.getNextSibling()获取当前 path 的后一个兄弟节点，返回的是 path 类型。</li><li>path.getAllNextSiblings()获取当前 path 的所有后兄弟节点，返回的是 Array 类型，其元素都是 path 类型。</li><li>path.evaluate()用于计算表达式的值，大家可以参考 constantFold 插件的写法。</li><li>path.findParent()向上查找满足回调函数特征的 path，即判断上级路径是否包含有 XXX 类型的节点。</li><li>path.find()功能与 path.findParent 方法一样，只不过从当前 path 开始进行遍历。</li><li>path.getFunctionParent()获取函数类型父节点，如果不存在，返回 null。</li><li>path.getStatementParent()获取 Statement 类型父节点，这个基本上都会有返回值，如果当前遍历的是 Program 或者 File 节点，则会报错。</li><li>path.getAncestry()获取所有的祖先节点，没有实参，返回的是一个 Array 对象。</li><li>path.isAncestor(maybeDescendant)判断当前遍历的节点是否为实参的祖先节点.</li><li>path.isDescendant(maybeAncestor)判断当前遍历的节点是否为实参的子孙节点.</li><li>path.traverse(visitor)遍历当前路径下的所有子节点，并应用指定的 visitor。</li><li>path.replaceWith(node)用指定的节点替换当前路径对应的节点。</li><li>path.remove()从 AST 中移除当前路径对应的节点。</li><li>path.insertBefore(nodes)在当前路径对应节点之前插入一个或多个节点。</li><li>path.insertAfter(nodes)在当前路径对应节点之后插入一个或多个节点。</li><li>path.toString()用于将 AST 节点转换回对应的源代码字符串。</li></ul><h2 id="3-2-Scope"><a href="#3-2-Scope" class="headerlink" title="3.2 Scope"></a>3.2 Scope</h2><p>函数：</p><ul><li>scope.block表示当前作用域下的所有 node，参考上面的 this.block &#x3D; node;</li><li>scope.dump()输出当前每个变量的作用域信息。调用后直接打印，不需要加打印函数</li><li>scope.crawl()重构 scope，在某种情况下会报错，不过还是建议在每一个插件的最后一行加上。</li><li>scope.rename(oldName, newName, block)修改当前作用域下的的指定的变量名，oldname、newname 表示替换前后的变量名，为字符串。注意，oldName 需要有 binding，否则无法重命名。</li><li>scope.traverse(node, opts, state)遍历当前作用域下的某些(个)插件。和全局的 traverse 用法一样。</li><li>scope.getBinding(name)获取某个变量的 binding，可以理解为其生命周期。包含引用，修改之类的信息</li></ul><p>属性：</p><ul><li>scope.block 可以用来获取标识符的作用域，返回 <code>Node</code> 对象，使用方法分为两种情况：<code>变量</code> 和 <code>函数</code>,变量获取当前作用域，函数获取函数本身作用域。</li><li></li></ul><h3 id="3-2-1-实例代码"><a href="#3-2-1-实例代码" class="headerlink" title="3.2.1 实例代码"></a>3.2.1 实例代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;mankvis&#x27;</span>,</span><br><span class="line">  <span class="attr">add</span>: <span class="keyword">function</span> (<span class="params">a</span>) &#123;</span><br><span class="line">    a = <span class="number">400</span>;</span><br><span class="line">    b = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">let</span> e = <span class="number">700</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">demo</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> d = <span class="number">600</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">demo</span>();</span><br><span class="line">    <span class="keyword">return</span> a + a + b + <span class="number">1000</span> + obj.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">add</span>(<span class="number">100</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-2-scope-block"><a href="#3-2-2-scope-block" class="headerlink" title="3.2.2 scope.block"></a>3.2.2 scope.block</h3><p>变量获取 block 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ast = parser.<span class="title function_">parse</span>(jsCode);</span><br><span class="line"></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">Identifier</span>(path) &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">name</span> === <span class="string">&#x27;e&#x27;</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generator</span>(path.<span class="property">scope</span>.<span class="property">block</span>).<span class="property">code</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function (a) &#123;</span></span><br><span class="line"><span class="comment">  a = 400;</span></span><br><span class="line"><span class="comment">  b = 300;</span></span><br><span class="line"><span class="comment">  let e = 700;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  function demo() &#123;</span></span><br><span class="line"><span class="comment">    let d = 600;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  demo();</span></span><br><span class="line"><span class="comment">  return a + a + b + 1000 + obj.name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数获取 block 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generator</span>(path.<span class="property">scope</span>.<span class="property">block</span>).<span class="property">code</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">function demo() &#123;</span></span><br><span class="line"><span class="comment">  let d = 600;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-3-scope-dump"><a href="#3-2-3-scope-dump" class="headerlink" title="3.2.3 scope.dump"></a>3.2.3 scope.dump</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n\n这里是函数&#x27;</span>, path.<span class="property">node</span>.<span class="property">id</span>.<span class="property">name</span> + <span class="string">&#x27;()&#x27;</span>);</span><br><span class="line">    path.<span class="property">scope</span>.<span class="title function_">dump</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里是函数 demo()</span></span><br><span class="line"><span class="comment">------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># FunctionDeclaration</span></span><br><span class="line"><span class="comment"> - d &#123; constant: true, references: 0, violations: 0, kind: &#x27;let&#x27; &#125;</span></span><br><span class="line"><span class="comment"># FunctionExpression</span></span><br><span class="line"><span class="comment"> - a &#123; constant: false, references: 2, violations: 1, kind: &#x27;param&#x27; &#125;</span></span><br><span class="line"><span class="comment"> - e &#123; constant: true, references: 0, violations: 0, kind: &#x27;let&#x27; &#125;</span></span><br><span class="line"><span class="comment"> - demo &#123; constant: true, references: 1, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span></span><br><span class="line"><span class="comment"># Program</span></span><br><span class="line"><span class="comment"> - a &#123; constant: true, references: 0, violations: 0, kind: &#x27;const&#x27; &#125;</span></span><br><span class="line"><span class="comment"> - b &#123; constant: false, references: 1, violations: 1, kind: &#x27;let&#x27; &#125;</span></span><br><span class="line"><span class="comment"> - obj &#123; constant: true, references: 2, violations: 0, kind: &#x27;let&#x27; &#125;</span></span><br><span class="line"><span class="comment">------------------------------------------------------------</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>‘#’开头的是每一个作用域 ，上面有三个作用域，分别是 FunctionDeclaration、FunctionExpression 和 Program。</li><li>‘-‘开头的是每一个绑定（binding），每一个 binding 都会包含几个关键信息，分别是：constant、references、violations、kind。<ul><li>constant 表示是否为常量，为布尔值</li><li>references 表示被引用的次数</li><li>violations 表示被重新定义的次数</li><li>kind 表示声明类型，param 参数、hoisted 提升、var 变量、local 内部。</li></ul></li></ul><h3 id="3-2-4-scope-getBinding"><a href="#3-2-4-scope-getBinding" class="headerlink" title="3.2.4 scope.getBinding"></a>3.2.4 scope.getBinding</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">let</span> bindingA = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bindingA);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Binding &#123;</span></span><br><span class="line"><span class="comment">  identifier: Node &#123;type: &#x27;Identifier&#x27;, ..., name: &#x27;a&#x27;&#125;,</span></span><br><span class="line"><span class="comment">  scope: Scope &#123;</span></span><br><span class="line"><span class="comment">    ...,</span></span><br><span class="line"><span class="comment">    block: Node &#123;type: &#x27;FunctionExpression&#x27;, ...&#125;</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">  path: NodePath &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  kind: &#x27;param&#x27;,</span></span><br><span class="line"><span class="comment">  constantViolations: [...],</span></span><br><span class="line"><span class="comment">  constant: false,</span></span><br><span class="line"><span class="comment">  referencePaths: [...],</span></span><br><span class="line"><span class="comment">  referenced: true,</span></span><br><span class="line"><span class="comment">  references: 2</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>getBinding 中传入的值必须是当前节点能够引用到的标识符名，如果传入一个不存在的 g ，这个标识符并不存在，或者说当前节点引用不到，那么 getBinding 会返回 undefined<br>由于 FunctionDeclaration 的作用域只是 demo 本身， demo 本身的作用域是 add 这个函数，所以是可以直接找到 a 的</p><ul><li>identifier 是 a 标识符的 Node 对象</li><li>path 是 a 表示符的 Path 对象</li><li>kind 表示这是一个参数，但是并不代表就是当前 demo 的参数。实际上原始代码中，a 是 add 的参数（当函数中局部变量与全局变量重名时，使用的是局部变量）</li><li>referencePaths 假设标识符被引用，referencePaths 中会存放所有引用该标识符的节点的 Path 对象</li><li>constantViolations 假如标识符被修改，那么 constantViolations 中会存放所有修改该标识符的节点的 Path 对象<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取函数作用域方法：</span></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionExpression</span>(path) &#123;</span><br><span class="line">    <span class="keyword">let</span> bindingA = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> bindingDemo = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bindingA.<span class="property">referenced</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(bindingA.<span class="property">references</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generator</span>(bindingA.<span class="property">scope</span>.<span class="property">block</span>).<span class="property">code</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generator</span>(bindingDemo.<span class="property">scope</span>.<span class="property">block</span>).<span class="property">code</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">下面代码输出2次</span></span><br><span class="line"><span class="comment">function (a) &#123;</span></span><br><span class="line"><span class="comment">  a = 400;</span></span><br><span class="line"><span class="comment">  b = 300;</span></span><br><span class="line"><span class="comment">  let e = 700;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  function demo() &#123;</span></span><br><span class="line"><span class="comment">    let d = 600;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  demo();</span></span><br><span class="line"><span class="comment">  return a + a + b + 1000 + obj.name;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-5-scope-getOwnBinding"><a href="#3-2-5-scope-getOwnBinding" class="headerlink" title="3.2.5 scope.getOwnBinding"></a>3.2.5 scope.getOwnBinding</h3><p><code>scope.getOwnBinding</code> 该函数用于获取当前节点自己的绑定，也就是不包含父级作用域中定义的标识符的绑定，但是该函数会得到子函数中定义的标识符的绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TestOwnBinding</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  path.<span class="title function_">traverse</span>(&#123;</span><br><span class="line">    <span class="title class_">Identifier</span>(p) &#123;</span><br><span class="line">      <span class="keyword">let</span> name = p.<span class="property">node</span>.<span class="property">name</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(name, !!p.<span class="property">scope</span>.<span class="title function_">getOwnBinding</span>(name));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionExpression</span>(path) &#123;</span><br><span class="line">    <span class="title class_">TestOwnBinding</span>(path);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">b false</span></span><br><span class="line"><span class="comment">e true</span></span><br><span class="line"><span class="comment">demo false</span></span><br><span class="line"><span class="comment">d true</span></span><br><span class="line"><span class="comment">demo true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">b false</span></span><br><span class="line"><span class="comment">obj false</span></span><br><span class="line"><span class="comment">name false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TestOwnBinding</span>(<span class="params">path</span>) &#123;</span><br><span class="line">  path.<span class="title function_">traverse</span>(&#123;</span><br><span class="line">    <span class="title class_">Identifier</span>(p) &#123;</span><br><span class="line">      <span class="keyword">let</span> name = p.<span class="property">node</span>.<span class="property">name</span>;</span><br><span class="line">      <span class="keyword">let</span> binding = p.<span class="property">scope</span>.<span class="title function_">getBinding</span>(name);</span><br><span class="line">      binding &amp;&amp; <span class="variable language_">console</span>.<span class="title function_">log</span>(name, <span class="title function_">generator</span>(binding.<span class="property">scope</span>.<span class="property">block</span>).<span class="property">code</span> === path.<span class="title function_">toString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionExpression</span>(path) &#123;</span><br><span class="line">    <span class="title class_">TestOwnBinding</span>(path);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">b false</span></span><br><span class="line"><span class="comment">e true</span></span><br><span class="line"><span class="comment">demo true</span></span><br><span class="line"><span class="comment">d false</span></span><br><span class="line"><span class="comment">demo true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">a true</span></span><br><span class="line"><span class="comment">b false</span></span><br><span class="line"><span class="comment">obj false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-6-scope-traverse"><a href="#3-2-6-scope-traverse" class="headerlink" title="3.2.6 scope.traverse"></a>3.2.6 scope.traverse</h3><p><code>scope.traverse</code> 方法可以用来遍历作用域中的节点。可以使用 <code>Path</code> 对象中的 <code>scope</code>，也可以使用 <code>Binding</code> 中的 <code>scope</code>，笔者推荐使用后者，下面来看下例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">let</span> binding = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    binding.<span class="property">scope</span>.<span class="title function_">traverse</span>(binding.<span class="property">scope</span>.<span class="property">block</span>, &#123;</span><br><span class="line">      <span class="title class_">AssignmentExpression</span>(p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.<span class="property">node</span>.<span class="property">left</span>.<span class="property">name</span> === <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">          p.<span class="property">node</span>.<span class="property">right</span> = types.<span class="title function_">numericLiteral</span>(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">const a = 1000;</span></span><br><span class="line"><span class="comment">let b = 2000;</span></span><br><span class="line"><span class="comment">let obj = &#123;</span></span><br><span class="line"><span class="comment">  name: &#x27;mankvis&#x27;,</span></span><br><span class="line"><span class="comment">  add: function (a) &#123;</span></span><br><span class="line"><span class="comment">    a = 500;</span></span><br><span class="line"><span class="comment">    b = 300;</span></span><br><span class="line"><span class="comment">    let e = 700;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    function demo() &#123;</span></span><br><span class="line"><span class="comment">      let d = 600;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    demo();</span></span><br><span class="line"><span class="comment">    return a + a + b + 1000 + obj.name;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">obj.add(100);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-7-scope-rename"><a href="#3-2-7-scope-rename" class="headerlink" title="3.2.7 scope.rename"></a>3.2.7 scope.rename</h3><p>可以使用 <code>scope.rename</code> 将标识符进行重命名，这个方法会同时修改所有引用该标识符的地方，例如将 <code>add</code> 函数中的 <code>b</code> 变量重命名为 <code>x</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionExpression</span>(path) &#123;</span><br><span class="line">    <span class="keyword">let</span> binding = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">    binding.<span class="property">scope</span>.<span class="title function_">rename</span>(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">const a = 1000;</span></span><br><span class="line"><span class="comment">let x = 2000;</span></span><br><span class="line"><span class="comment">let obj = &#123;</span></span><br><span class="line"><span class="comment">  name: &#x27;mankvis&#x27;,</span></span><br><span class="line"><span class="comment">  add: function (a) &#123;</span></span><br><span class="line"><span class="comment">    a = 400;</span></span><br><span class="line"><span class="comment">    x = 300;</span></span><br><span class="line"><span class="comment">    let e = 700;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    function demo() &#123;</span></span><br><span class="line"><span class="comment">      let d = 600;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    demo();</span></span><br><span class="line"><span class="comment">    return a + a + x + 1000 + obj.name;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">obj.add(100);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述方法很方便的就把 <code>b</code> 改为了 <code>x</code>，但是如果随便指定一个变量名，可能会与现有标识符发生命名冲突，这时可以使用 <code>scope.generateUidIdentifier</code> 来生成一个标识符，生成的标识符不会与任何本地的标识符相冲突，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line"> <span class="title class_">FunctionExpression</span>(path) &#123;</span><br><span class="line">   path.<span class="property">scope</span>.<span class="title function_">generateUidIdentifier</span>(<span class="string">&#x27;uid&#x27;</span>);</span><br><span class="line">   <span class="comment">// Node &#123;type: &quot;Identifier&quot;, name: &quot;_uid&quot;&#125;</span></span><br><span class="line">   path.<span class="property">scope</span>.<span class="title function_">generateUidIdentifier</span>(<span class="string">&#x27;_uid2&#x27;</span>);</span><br><span class="line">   <span class="comment">// Node &#123;type: &quot;Identifier&quot;, name: &quot;_uid2&quot;&#125;</span></span><br><span class="line"> &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-8-scope-hasBinding"><a href="#3-2-8-scope-hasBinding" class="headerlink" title="3.2.8 scope.hasBinding"></a>3.2.8 scope.hasBinding</h3><p>该方法查询某标识符是否有绑定，返回 <code>true</code> 或者 <code>false</code>。可以用 <code>scope.getBinding(&quot;a&quot;)</code> 代替，<code>scope.getBinding(&quot;a&quot;)</code> 返回 <code>undefined</code>，等同于 <code>scope.hasBinding(&quot;a&quot;)</code> 返回 <code>false</code>。</p><h3 id="3-2-9-scope-hasOwnBinding"><a href="#3-2-9-scope-hasOwnBinding" class="headerlink" title="3.2.9 scope.hasOwnBinding"></a>3.2.9 scope.hasOwnBinding</h3><p>该方法查询当前节点中是否有自己的绑定，返回布尔值，例如，对于 <code>demo</code> 函数，<code>OwnBinding</code> 只有一个 <code>d</code>，函数名 <code>demo</code> 虽然也是标识符，但不属于 <code>demo</code> 函数的 <code>OwnBinding</code> 范畴，是属于它的父级作用域中的，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="property">scope</span>.<span class="property">parent</span>.<span class="title function_">hasOwnBinding</span>(<span class="string">&#x27;demo&#x27;</span>));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-10-scope-getAllBindings"><a href="#3-2-10-scope-getAllBindings" class="headerlink" title="3.2.10 scope.getAllBindings"></a>3.2.10 scope.getAllBindings</h3><p>该方法获取当前节点的所有绑定，会返回一个对象。该对象以标识符名为属性名，对应的 <code>Binding</code> 为属性值，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="property">scope</span>.<span class="title function_">getAllBindings</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[Object: null prototype] &#123;</span></span><br><span class="line"><span class="comment">  d: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  a: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  demo: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  e: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  b: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">  obj: Binding &#123;...&#125;,</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>遍历每一个 <code>Binding</code>，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">traverse</span>(ast, &#123;</span><br><span class="line">  <span class="title class_">BlockStatement</span>(path) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\n此块节点源码: \n&#x27;</span>, path.<span class="title function_">toString</span>());</span><br><span class="line">    <span class="keyword">let</span> bindings = path.<span class="property">scope</span>.<span class="property">bindings</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;作用域内被绑定数量:&#x27;</span>, <span class="title class_">Object</span>.<span class="title function_">keys</span>(bindings).<span class="property">length</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> bindingsKey <span class="keyword">in</span> bindings) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;名字&#x27;</span>, bindingsKey);</span><br><span class="line">      <span class="keyword">let</span> binding_ = bindings[bindingsKey];</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;类型:&#x27;</span>, binding_.<span class="property">kind</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定义:&#x27;</span>, binding_.<span class="property">identifier</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是否常量:&#x27;</span>, binding_.<span class="property">constant</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被修改信息记录:&#x27;</span>, binding_.<span class="property">constantViolations</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;是否被引用:&#x27;</span>, binding_.<span class="property">referenced</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被引用次数:&#x27;</span>, binding_.<span class="property">references</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;被引用信息NodePath记录&#x27;</span>, binding_.<span class="property">referencePaths</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;-------------------------------------&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-11-scope-hasReference"><a href="#3-2-11-scope-hasReference" class="headerlink" title="3.2.11 scope .hasReference"></a>3.2.11 scope .hasReference</h3><p>scope.hasReference(“a”) 表示查询当前节点中是否有 a 标识符的引用，返回布尔值。</p><h3 id="3-2-12-scope-getBindingIdentifier"><a href="#3-2-12-scope-getBindingIdentifier" class="headerlink" title="3.2.12 scope .getBindingIdentifier"></a>3.2.12 scope .getBindingIdentifier</h3><p>scope.getBindingIdentifier(“a”) 表示获取当前节点中绑定的 a 的标识符，返回 Identifier 的 Node 对象。同样，这个方法也有 Own 版本，为 scope.getOwnBindingIdentifier(“a”)。</p><h2 id="3-3-node"><a href="#3-3-node" class="headerlink" title="3.3 node"></a>3.3 node</h2><p>属性：</p><ul><li>path.node.type获取当前节点的类型。</li><li>path.node.declarations对于 VariableDeclaration 节点, 获取变量声明列表。</li><li>path.node.init.value获取某个节点的值。</li><li>delete path.node.init;删除节点，使用系统的 delete 方法。</li></ul><h2 id="3-4-types-类型"><a href="#3-4-types-类型" class="headerlink" title="3.4 types 类型"></a>3.4 types 类型</h2><h2 id="3-5-节点类型对照"><a href="#3-5-节点类型对照" class="headerlink" title="3.5 节点类型对照"></a>3.5 节点类型对照</h2><ul><li>Program程序主体整段代码的主体</li><li>VariableDeclaration变量声明声明一个变量，例如 var let const</li><li>FunctionDeclaration函数声明声明一个函数，例如 function</li><li>ExpressionStatement表达式语句通常是调用一个函数，例如 console.log()</li><li>BlockStatement块语句包裹在 {} 块内的代码，例如 if (condition){var a &#x3D; 1;}</li><li>BreakStatement中断语句通常指 break</li><li>ContinueStatement持续语句通常指 continue</li><li>ReturnStatement返回语句通常指 return</li><li>SwitchStatementSwitch 语句通常指 Switch Case 语句中的 Switch</li><li>IfStatementIf 控制流语句控制流语句，通常指 if(condition){}else{}</li><li>Identifier标识符标识，例如声明变量时 var identi &#x3D; 5 中的 identi</li><li>CallExpression调用表达式通常指调用一个函数，例如 console.log()</li><li>BinaryExpression二进制表达式通常指运算，例如 1+2</li><li>MemberExpression成员表达式通常指调用对象的成员，例如 console 对象的 log 成员</li><li>ArrayExpression数组表达式通常指一个数组，例如 [1, 3, 5]</li><li>NewExpressionNew 表达式通常指使用 New 关键词</li><li>AssignmentExpression赋值表达式通常指将函数的返回值赋值给变量</li><li>UpdateExpression更新表达式通常指更新成员值，例如 i++</li><li>Literal字面量字面量</li><li>BooleanLiteral布尔型字面量布尔值，例如 true false</li><li>NumericLiteral数字型字面量数字，例如 100</li><li>StringLiteral字符型字面量字符串，例如 vansenb</li><li>SwitchCaseCase 语句通常指 Switch 语句中的 Case</li><li>SequenceExpression 一个序列表达式，也就是由逗号分割的表达式序列</li><li>FunctionExpression 函数赋值语句</li></ul><h1 id="4-常用技巧"><a href="#4-常用技巧" class="headerlink" title="4 常用技巧"></a>4 常用技巧</h1><h2 id="4-1-基础使用框架"><a href="#4-1-基础使用框架" class="headerlink" title="4.1 基础使用框架"></a>4.1 基础使用框架</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// decrypt.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> util = <span class="built_in">require</span>(<span class="string">&#x27;util&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).<span class="property">default</span>;</span><br><span class="line"><span class="keyword">const</span> types = <span class="built_in">require</span>(<span class="string">&#x27;@babel/types&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> generator = <span class="built_in">require</span>(<span class="string">&#x27;@babel/generator&#x27;</span>).<span class="property">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序启动时间</span></span><br><span class="line"><span class="keyword">var</span> time_start = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line">process.<span class="property">argv</span>.<span class="property">length</span> &gt; <span class="number">2</span> ? encode_file = process.<span class="property">argv</span>[<span class="number">2</span>] : encode_file = <span class="string">&#x27;encode.js&#x27;</span>;</span><br><span class="line">process.<span class="property">argv</span>.<span class="property">length</span> &gt; <span class="number">3</span> ? decode_file = process.<span class="property">argv</span>[<span class="number">3</span>] : decode_file = <span class="string">&#x27;decode.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jscode = fs.<span class="title function_">readFileSync</span>(encode_file, &#123;<span class="attr">encoding</span>: <span class="string">&#x27;utf-8&#x27;</span>&#125;);</span><br><span class="line"><span class="comment">// 转换为 ast 树</span></span><br><span class="line"><span class="keyword">let</span> ast = parser.<span class="title function_">parse</span>(jscode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> visitor =</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此处编写 babel 处理代码、插件代码</span></span><br><span class="line">        <span class="title class_">ASTNodeTypeHere</span>(path, state) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如</span></span><br><span class="line">        <span class="comment">// Identifier(path, state) &#123;&#125;</span></span><br><span class="line">        <span class="comment">// Identifier(path) &#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用插件，处理待处理 js ast 树</span></span><br><span class="line"><span class="title function_">traverse</span>(ast, visitor);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;AST traverse completed.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成处理后的 js</span></span><br><span class="line"><span class="keyword">let</span> &#123;code&#125; = <span class="title function_">generator</span>(ast);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;AST generator completed.&#x27;</span>)</span><br><span class="line">fs.<span class="title function_">writeFile</span>(decode_file, code, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(util.<span class="title function_">format</span>(<span class="string">&#x27;The javascript code in [%s] has been processed.&#x27;</span>, encode_file))</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(util.<span class="title function_">format</span>(<span class="string">&#x27;The processing result has been saved to [%s].&#x27;</span>, decode_file))</span><br><span class="line"><span class="comment">// 程序结束时间</span></span><br><span class="line"><span class="keyword">var</span> time_end = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(util.<span class="title function_">format</span>(<span class="string">&#x27;The program runs to completion, time-consuming: %s s&#x27;</span>, (time_end - time_start) / <span class="number">1000</span>))</span><br></pre></td></tr></table></figure><h2 id="4-2-打印原来的节点的源码-toString"><a href="#4-2-打印原来的节点的源码-toString" class="headerlink" title="4.2 打印原来的节点的源码 toString()"></a>4.2 打印原来的节点的源码 toString()</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> js = <span class="string">&#x27;var a = 1&#x27;</span></span><br><span class="line"><span class="keyword">const</span> visitor = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">VariableDeclarator</span>(path)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">toString</span>()); <span class="comment">// a = 1</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">generator</span>(path.<span class="property">node</span>).<span class="property">code</span>) <span class="comment">// a= 1</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-构造节点-t-valueToNode"><a href="#4-3-构造节点-t-valueToNode" class="headerlink" title="4.3 构造节点 t.valueToNode()"></a>4.3 构造节点 t.valueToNode()</h2><p>(可以代替t.NumericLiteral(234567)，t.StringLiteral(‘1234’) 注意：使用这两种过传参类型必须和声明类型一样，如果使用 valueNode 的话就是传入参数的默认类型)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="title class_">VariableDeclarator</span>(path)&#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="title function_">valueToNode</span>(<span class="string">&#x27;123&#x27;</span>));  <span class="comment">// &#123; type: &#x27;StringLiteral&#x27;, value: &#x27;123&#x27; &#125;</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="title function_">valueToNode</span>(<span class="number">123</span>));  <span class="comment">//  &#123; type: &#x27;NumericLiteral&#x27;, value: 123 &#125;</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="title function_">valueToNode</span>(<span class="literal">null</span>))  <span class="comment">//  &#123; type: &#x27;NullLiteral&#x27; &#125;</span></span><br><span class="line"> &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-4-替换节点-replaceWith"><a href="#4-4-替换节点-replaceWith" class="headerlink" title="4.4 替换节点 replaceWith"></a>4.4 替换节点 replaceWith</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;VariableDeclarator&#x27;</span>(path)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">toString</span>());  <span class="comment">//a = 1</span></span><br><span class="line">        path.<span class="title function_">replaceWith</span>(t.<span class="title function_">valueToNode</span>(<span class="number">1</span>)) <span class="comment">//var 1;</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-删除节点-remove"><a href="#4-5-删除节点-remove" class="headerlink" title="4.5 删除节点 remove()"></a>4.5 删除节点 remove()</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;VariableDeclarator&#x27;</span>(path)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">toString</span>())  <span class="comment">// a = 1 + 2;b = 2</span></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="property">node</span>.<span class="property">id</span>.<span class="property">name</span> === <span class="string">&#x27;b&#x27;</span>)&#123;</span><br><span class="line">        path.<span class="title function_">remove</span>()&#125;; </span><br><span class="line">&#125;&#125; <span class="comment">// 还原为var a = 1 + 2;</span></span><br></pre></td></tr></table></figure><h2 id="4-6-判断节点类型-isVariableDeclarator"><a href="#4-6-判断节点类型-isVariableDeclarator" class="headerlink" title="4.6 判断节点类型 isVariableDeclarator"></a>4.6 判断节点类型 isVariableDeclarator</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;VariableDeclarator&#x27;</span>(path)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">toString</span>()) <span class="comment">//a = 1 + 2</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="property">type</span>); <span class="comment">// VariableDeclarator</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(t.<span class="title function_">isVariableDeclarator</span>(path.<span class="property">node</span>))  <span class="comment">//true</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">isVariableDeclarator</span>()) <span class="comment">// true</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7-节点设置值-set-key-node"><a href="#4-7-节点设置值-set-key-node" class="headerlink" title="4.7 节点设置值 set(key,node)"></a>4.7 节点设置值 set(key,node)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="comment">// 将var a修改为 var a</span></span><br><span class="line">    <span class="string">&#x27;VariableDeclarator&#x27;</span>(path)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(path.<span class="title function_">toString</span>())  <span class="comment">//a</span></span><br><span class="line">        <span class="keyword">const</span> &#123;init&#125; = path.<span class="property">node</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(init === path.<span class="property">node</span>.<span class="property">init</span>) <span class="comment">//true</span></span><br><span class="line">        init || path.<span class="title function_">set</span>(<span class="string">&#x27;init&#x27;</span>, t.<span class="title class_">Identifier</span>(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">&#125;&#125; <span class="comment">//输出为var a = 1;</span></span><br></pre></td></tr></table></figure><h2 id="4-8-插入节点"><a href="#4-8-插入节点" class="headerlink" title="4.8 插入节点"></a>4.8 插入节点</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;Identifier&#x27;</span> (path) &#123;</span><br><span class="line">        path.<span class="title function_">insertBefore</span>(t.<span class="title function_">valueToNode</span>(<span class="string">&#x27;22&#x27;</span>)); <span class="comment">//节点前插入</span></span><br><span class="line">        path.<span class="title function_">insertAfter</span>(t.<span class="title function_">valueToNode</span>(<span class="string">&#x27;22&#x27;</span>));<span class="comment">//节点后插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-高级技巧"><a href="#5-高级技巧" class="headerlink" title="5 高级技巧"></a>5 高级技巧</h1><h2 id="5-1-执行-path"><a href="#5-1-执行-path" class="headerlink" title="5.1 执行 path"></a>5.1 执行 path</h2><p>使用 <code>path.evaluate()</code> ，返回的 <code>confident</code> 为 <code>true</code> 则表明成功执行，<code>value</code> 为返回值<br>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; confident, value &#125; = path.evaluate();</span><br></pre></td></tr></table></figure><h2 id="5-2-多个节点组合查询"><a href="#5-2-多个节点组合查询" class="headerlink" title="5.2 多个节点组合查询"></a>5.2 多个节点组合查询</h2><p>使用 <code>|</code> 把需要访问的节点组合起来即可，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor = &#123;</span><br><span class="line">  <span class="string">&#x27;VariableDeclarator|FunctionDeclaration&#x27;</span>(path) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">traverse</span>(ast, visitor);</span><br></pre></td></tr></table></figure><h2 id="5-3-删除无用的空语句"><a href="#5-3-删除无用的空语句" class="headerlink" title="5.3 删除无用的空语句"></a>5.3 删除无用的空语句</h2><p>删除空语句 <code>;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;EmptyStatement&#x27;</span>(path) &#123;</span><br><span class="line">    path.<span class="title function_">remove</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4-删除无用节点"><a href="#5-4-删除无用节点" class="headerlink" title="5.4 删除无用节点"></a>5.4 删除无用节点</h2><p>&#96;path.remove()</p><h2 id="5-5-查看作用域-scope"><a href="#5-5-查看作用域-scope" class="headerlink" title="5.5 查看作用域 scope"></a>5.5 查看作用域 scope</h2><p><code>path.scope.dump()</code> 即可查看自底向上的作用域</p><h2 id="5-6-同一节点使用多个函数"><a href="#5-6-同一节点使用多个函数" class="headerlink" title="5.6 同一节点使用多个函数"></a>5.6 同一节点使用多个函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">log_a</span>(<span class="params">path</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is [a] function -- &#x27;</span> + path.<span class="property">node</span>.<span class="property">init</span>.<span class="property">value</span>); &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log_b</span>(<span class="params">path</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is [b] function -- &#x27;</span> + path.<span class="property">node</span>.<span class="property">init</span>.<span class="property">value</span>); &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">log_c</span>(<span class="params">path</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;This is [c] function -- &#x27;</span> + path.<span class="property">node</span>.<span class="property">init</span>.<span class="property">value</span>); &#125;</span><br><span class="line"><span class="keyword">const</span> visitor =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;VariableDeclarator&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;enter&#x27;</span>: [log_a, log_c, log_b]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">traverse</span>(ast, visitor);</span><br></pre></td></tr></table></figure><p><strong>请注意！</strong><br><strong>enter 需为数组！函数执行顺序为列表中函数顺序！</strong></p><h2 id="5-7-删除未使用的-function、var、let、const"><a href="#5-7-删除未使用的-function、var、let、const" class="headerlink" title="5.7 删除未使用的 function、var、let、const"></a>5.7 删除未使用的 function、var、let、const</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="title class_">VariableDeclarator</span>(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = path.<span class="property">node</span>;</span><br><span class="line">    <span class="keyword">let</span> binding = path.<span class="property">scope</span>.<span class="title function_">getBinding</span>(id.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binding.<span class="property">referenced</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="title function_">remove</span>();</span><br><span class="line">    path.<span class="property">scope</span>.<span class="title function_">crawl</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title class_">FunctionDeclaration</span>(path) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = path.<span class="property">node</span>;</span><br><span class="line">    <span class="comment">// 防止函数中存在变量与函数名相同，且该变量在函数中使用，导致未去除未使用函数</span></span><br><span class="line">    <span class="keyword">let</span> binding = path.<span class="property">scope</span>.<span class="property">parent</span>.<span class="title function_">getBinding</span>(id.<span class="property">name</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (binding.<span class="property">referenced</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="title function_">remove</span>();</span><br><span class="line">    <span class="comment">// 手动更新 scope ，防止影响下个插件使用</span></span><br><span class="line">    path.<span class="property">scope</span>.<span class="title function_">crawl</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-8-a-‘bb’-转换为-a-bb"><a href="#5-8-a-‘bb’-转换为-a-bb" class="headerlink" title="5.8 a[‘bb’] 转换为 a.bb"></a>5.8 a[‘bb’] 转换为 a.bb</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> visitor =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="title class_">MemberExpression</span>(path) &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; computed &#125; = path.<span class="property">node</span>;</span><br><span class="line">        <span class="comment">// 获取 path property 子路径</span></span><br><span class="line">        <span class="keyword">let</span> property = path.<span class="title function_">get</span>(<span class="string">&#x27;property&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (computed &amp;&amp; types.<span class="title function_">isStringLiteral</span>(property)) &#123;</span><br><span class="line">            property.<span class="title function_">replaceWith</span>(types.<span class="title function_">identifier</span>(property.<span class="property">node</span>.<span class="property">value</span>));</span><br><span class="line">            path.<span class="property">node</span>.<span class="property">computed</span>=<span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-9-简单控制流"><a href="#5-9-简单控制流" class="headerlink" title="5.9 简单控制流"></a>5.9 简单控制流</h2><p>待处理代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="string">&quot;3|0|1|2|4&quot;</span>.<span class="title function_">split</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (arr[cnt++]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;0&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is case-block 0&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;1&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is case-block 1&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;2&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is case-block 2&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;3&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is case-block 3&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;4&quot;</span>:</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;This is case-block 4&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单还原后的结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;This is case-block 3&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;This is case-block 0&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;This is case-block 1&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;This is case-block 2&quot;</span>);</span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">&quot;This is case-block 4&quot;</span>);</span><br></pre></td></tr></table></figure><p>插件为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&#x27;WhileStatement&#x27;</span>(path)&#123;</span><br><span class="line">      <span class="comment">// console.log(path.node)</span></span><br><span class="line">      <span class="keyword">const</span> &#123;test, body&#125; = path.<span class="property">node</span>;</span><br><span class="line">      <span class="keyword">if</span> (!t.<span class="title function_">isBooleanLiteral</span>(test) || test.<span class="property">value</span> !== <span class="literal">true</span>)&#123;<span class="keyword">return</span>&#125;;</span><br><span class="line">      <span class="keyword">if</span> (body.<span class="property">body</span>.<span class="property">length</span> === <span class="number">0</span> || !t.<span class="title function_">isSwitchStatement</span>(body.<span class="property">body</span>[<span class="number">0</span>])) &#123;<span class="keyword">return</span>&#125;;</span><br><span class="line">      <span class="keyword">let</span> switch_state = body.<span class="property">body</span>[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">let</span>&#123;discriminant, cases&#125; = switch_state;</span><br><span class="line">      <span class="keyword">if</span> (!t.<span class="title function_">isMemberExpression</span>(discriminant) || !t.<span class="title function_">isUpdateExpression</span>(discriminant.<span class="property">property</span>))&#123;<span class="keyword">return</span>&#125;;</span><br><span class="line">      <span class="comment">//获取while循环变量名称</span></span><br><span class="line">      <span class="keyword">let</span> arr_name = discriminant.<span class="property">object</span>.<span class="property">name</span>;</span><br><span class="line">      <span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、获取while所有以上兄弟节点，获取控制流属组</span></span><br><span class="line">      <span class="keyword">let</span> all_pre_siblings = path.<span class="title function_">getAllPrevSiblings</span>();</span><br><span class="line">      <span class="keyword">if</span> (all_pre_siblings.<span class="property">length</span> !== <span class="number">2</span>)&#123;<span class="keyword">return</span>&#125;;</span><br><span class="line"><span class="comment">//2、根据循环变量名称判断控制流属组位置</span></span><br><span class="line">      all_pre_siblings.<span class="title function_">forEach</span>(<span class="function"><span class="params">pre_pth</span> =&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">const</span> &#123;declarations&#125; = pre_pth.<span class="property">node</span>;</span><br><span class="line">          <span class="keyword">let</span> &#123;id, init&#125; = declarations[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">if</span> (arr_name == id.<span class="property">name</span>)&#123;</span><br><span class="line">              arr = init.<span class="property">callee</span>.<span class="property">object</span>.<span class="property">value</span>.<span class="title function_">split</span>(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          pre_pth.<span class="title function_">remove</span>();</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">let</span> ret_body = [];</span><br><span class="line">      arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">index</span> =&gt;</span>&#123;</span><br><span class="line">          <span class="keyword">let</span> case_body = cases[index].<span class="property">consequent</span>;</span><br><span class="line">          <span class="comment">//如果case里面含有continue语句，将属组弹出</span></span><br><span class="line">          <span class="keyword">if</span> (t.<span class="title function_">isContinueStatement</span>(case_body[case_body.<span class="property">length</span> -<span class="number">1</span>]))</span><br><span class="line">              &#123;case_body.<span class="title function_">pop</span>()&#125;</span><br><span class="line">          ret_body = ret_body.<span class="title function_">concat</span>(case_body)</span><br><span class="line">      &#125;)</span><br><span class="line">      path.<span class="title function_">replaceInline</span>(ret_body)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="5-10-自执行函数替换（固定函数参数）"><a href="#5-10-自执行函数替换（固定函数参数）" class="headerlink" title="5.10 自执行函数替换（固定函数参数）"></a>5.10 自执行函数替换（固定函数参数）</h2><p>待处理代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span>(<span class="params">a,b</span>) &#123;c = a | b;&#125;(<span class="number">111</span>,<span class="number">222</span>);</span><br></pre></td></tr></table></figure><p>简单还原后的结果为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!<span class="keyword">function</span>(<span class="params"></span>) &#123;c = <span class="number">111</span> | <span class="number">222</span>&#125;();</span><br></pre></td></tr></table></figure><p>插件为：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CallExpression(path) &#123;</span><br><span class="line">        <span class="keyword">let</span> callee = path.<span class="keyword">get</span>(<span class="string">&#x27;callee&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> arguments = path.<span class="keyword">get</span>(<span class="string">&#x27;arguments&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!callee.isFunctionExpression() || arguments.length === <span class="number">0</span>) &#123; <span class="comment">//这里实参的长度判断可以写死。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对着网站解析，获取形参</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">params</span> = callee.<span class="keyword">get</span>(<span class="string">&#x27;params&#x27;</span>);</span><br><span class="line">        <span class="keyword">let</span> scope = callee.scope;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arguments.length; i++) &#123; <span class="comment">//遍历实参，因为形参可能比实参长。</span></span><br><span class="line">            <span class="keyword">let</span> arg = <span class="keyword">params</span>[i];</span><br><span class="line">            <span class="keyword">let</span> &#123;</span><br><span class="line">                name</span><br><span class="line">            &#125; = arg.node;</span><br><span class="line">            <span class="keyword">const</span> binding = scope.getBinding(name); <span class="comment">// 在当前作用域中，找到参数的引用</span></span><br><span class="line">            console.log(binding)</span><br><span class="line">            <span class="keyword">if</span> (!binding || binding.constantViolations.length &gt; <span class="number">0</span>) &#123; <span class="comment">//形参有被改变，不能被还原</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">// 表示在当前作用域中的引用，因为现在的作用域是整个函数，所有如果&#x27;!function(a,b) &#123;c = a | b;a=1&#125;(111,222);&#x27;或者&#x27;!function(a,b) &#123;a=1;c = a | b&#125;(111,222);&#x27;是无法修改a的值的</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (refer_path of binding.referencePaths) &#123; <span class="comment">//因为是字面量，所以直接替换，但是遇到Array类型的需要另外处理</span></span><br><span class="line">                <span class="comment">//也无非获取父节点，然后判断索引</span></span><br><span class="line">                refer_path.replaceWith(arguments[i]);</span><br><span class="line">                <span class="comment">//上面的参数可以是path，也可以是node。但是我遇到过path报错，node可以的情况。</span></span><br><span class="line">            &#125;</span><br><span class="line">            arg.<span class="keyword">remove</span>();</span><br><span class="line">            arguments[i].<span class="keyword">remove</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-学习网站&quot;&gt;&lt;a href=&quot;#1-学习网站&quot; class=&quot;headerlink&quot; title=&quot;1 学习网站&quot;&gt;&lt;/a&gt;1 学习网站&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blogz.gitee.io/ast/&quot;&gt;AST explor</summary>
      
    
    
    
    <category term="JS逆向" scheme="http://suzi007.github.io/categories/JS%E9%80%86%E5%90%91/"/>
    
    <category term="逆向工具" scheme="http://suzi007.github.io/categories/JS%E9%80%86%E5%90%91/%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="JS逆向" scheme="http://suzi007.github.io/tags/JS%E9%80%86%E5%90%91/"/>
    
    <category term="AST还原" scheme="http://suzi007.github.io/tags/AST%E8%BF%98%E5%8E%9F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈协议攻击常用方法与防御性渗透</title>
    <link href="http://suzi007.github.io/2024/04/17/%E6%B5%85%E8%B0%88%E5%8D%8F%E8%AE%AE%E6%94%BB%E5%87%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E9%98%B2%E5%BE%A1%E6%80%A7%E6%B8%97%E9%80%8F/"/>
    <id>http://suzi007.github.io/2024/04/17/%E6%B5%85%E8%B0%88%E5%8D%8F%E8%AE%AE%E6%94%BB%E5%87%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E9%98%B2%E5%BE%A1%E6%80%A7%E6%B8%97%E9%80%8F/</id>
    <published>2024-04-17T07:11:11.000Z</published>
    <updated>2025-01-03T02:25:14.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-协议攻击常用思路"><a href="#1-协议攻击常用思路" class="headerlink" title="1 协议攻击常用思路"></a>1 协议攻击常用思路</h1><blockquote><p><strong>爬虫常用的 js 逆向思路：</strong></p></blockquote><ol><li>找核心逻辑（参数加密、处理逻辑）</li><li>复写加密算法&#x2F;抠核心 js — node.js 模拟执行 &#x2F; 其他 V 8 引擎执行 ：</li><li>模拟发送请求</li><li>保存采集的数据并对数据进行处理</li></ol><h1 id="2-协议攻击防御思路"><a href="#2-协议攻击防御思路" class="headerlink" title="2 协议攻击防御思路"></a>2 协议攻击防御思路</h1><blockquote><p><strong>防御方反爬的思路：</strong></p></blockquote><ol><li>如何增加对方复写算法的难度</li><li>如何增加对方抠核心 js 的难度</li><li>如何阻止对方使用 node.js &#x2F; 其他 V 8 引擎执行 js</li></ol><blockquote><p><strong>防御方一般的解决方法：</strong></p></blockquote><ol><li>可以利用算法魔改且增大算法长度来处理</li><li>可以利用代码混淆操作来处理</li><li>就需要针对于 node.js、VM 2、V 8 执行环境进行对抗</li></ol><blockquote><p><strong>主流执行 js 的方案：</strong></p></blockquote><ol><li>node.js 直接执行，node.js 相关的沙箱直接执行 —&gt; vm 2</li><li>使用开源的&#x2F;闭源纯净 v 8 进行执行</li><li>使用魔改浏览器&#x2F;原生浏览器&#x2F;无头浏览器环境进行执行</li><li>其余的骚操作 —- 这个暂时不考虑</li></ol><blockquote><p>协议攻击防御思路最终目的是增大玩协议的爬虫工程师的难度，让爬虫的采集成本大于数据价值本身，<strong>比对主流浏览器和其他非法环境的区别</strong>，然后制作检查点识别特殊环境，禁止其访问或降低其权限。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-协议攻击常用思路&quot;&gt;&lt;a href=&quot;#1-协议攻击常用思路&quot; class=&quot;headerlink&quot; title=&quot;1 协议攻击常用思路&quot;&gt;&lt;/a&gt;1 协议攻击常用思路&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;爬虫常用的 js 逆向思路：&lt;/s</summary>
      
    
    
    
    <category term="爬虫防护" scheme="http://suzi007.github.io/categories/%E7%88%AC%E8%99%AB%E9%98%B2%E6%8A%A4/"/>
    
    <category term="爬虫防护" scheme="http://suzi007.github.io/categories/%E7%88%AC%E8%99%AB%E9%98%B2%E6%8A%A4/%E7%88%AC%E8%99%AB%E9%98%B2%E6%8A%A4/"/>
    
    
    <category term="爬虫防护" scheme="http://suzi007.github.io/tags/%E7%88%AC%E8%99%AB%E9%98%B2%E6%8A%A4/"/>
    
  </entry>
  
  <entry>
    <title>kali 终端提升效率神器tmux</title>
    <link href="http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/kali%20%E7%BB%88%E7%AB%AF%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8tmux/"/>
    <id>http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/kali%E7%A5%9E%E5%99%A8/kali%20%E7%BB%88%E7%AB%AF%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87%E7%A5%9E%E5%99%A8tmux/</id>
    <published>2024-04-17T07:11:11.000Z</published>
    <updated>2025-03-29T15:56:23.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装</span><br><span class="line">apt-get install tmux</span><br><span class="line">切换默认shell</span><br><span class="line">chat /etc/shells</span><br><span class="line">chsh -s /usr/bin/tmux</span><br></pre></td></tr></table></figure><h1 id="2-使用-tmux"><a href="#2-使用-tmux" class="headerlink" title="2 使用.tmux"></a>2 使用.tmux</h1><blockquote><p>tmux 的工作机制可以分为三大部分：会话（Session）、窗口（Window）和面板（Pane）。每个部分都有其独特功能和作用：</p></blockquote><ul><li>会话（Session）：一个独立的工作实例。每个会话可以包含多个窗口，且可以独立于其他会话运行。即使 SSH 连接断开，tmux 也能保持会话的完整状态，保障程序不会中断。重新连接时，只需恢复会话即可。</li><li>窗口（Window）：会话中的窗口类似于多标签页，允许在同一会话中分割出不同的任务区。每个窗口可以包含多个面板，并且可以随时切换。</li><li>面板（Pane）：窗口中的分屏区域，每个面板都可以执行不同的任务。你可以在一个窗口中分割出多个面板，以便在同一屏幕下查看和操作多个任务。</li></ul><h2 id="2-1-会话管理命令"><a href="#2-1-会话管理命令" class="headerlink" title="2.1 会话管理命令"></a>2.1 会话管理命令</h2><ul><li>新建会话：<ul><li>命令：tmux new -s &lt;会话名&gt; [-n 窗口名]</li><li>说明：新建一个指定名称的会话，可选参数 -n 用于指定初始窗口的名称。</li><li>使用场景：在终端外新建 tmux 会话，便于将不同任务组织在独立的会话中。</li></ul></li><li>恢复会话：<ul><li>命令：tmux attach -t &lt;会话名&gt; 或 tmux at -t &lt;会话名&gt;</li><li>说明：恢复到已存在的会话，让你重新回到之前的工作环境。</li><li>使用场景：当暂时离开会话后，通过该命令继续之前的工作，避免重新配置窗口和窗格。</li></ul></li><li>列出所有会话：<ul><li>命令：tmux ls</li><li>说明：查看当前所有的会话及其状态，显示会话名、窗口数等信息。</li><li>使用场景：有多个会话时，列出所有会话帮助定位特定会话的名称和状态。</li></ul></li><li>删除会话：<ul><li>命令：tmux kill-session -t &lt;会话名&gt;</li><li>说明：关闭指定的会话，释放资源。</li><li>使用场景：在会话任务完成后手动删除不再需要的会话。</li></ul></li><li>关闭所有会话：<ul><li>命令：tmux kill-server</li><li>说明：彻底关闭 tmux 服务及所有会话。</li><li>使用场景：退出 tmux 前清理所有会话，非常适合不再需要保持任何会话时使用。</li></ul></li></ul><h2 id="2-2-快捷键"><a href="#2-2-快捷键" class="headerlink" title="2.2 快捷键"></a>2.2 快捷键</h2><h3 id="2-2-1-会话管理快捷键"><a href="#2-2-1-会话管理快捷键" class="headerlink" title="2.2.1 会话管理快捷键"></a>2.2.1 会话管理快捷键</h3><ul><li>分离当前会话：Ctrl + b 后按 d 或者输入 tmux detach<ul><li>将当前会话转为后台运行，允许你暂时离开而不终止会话，稍后可以通过恢复会话继续工作。</li></ul></li><li>重命名当前会话：Ctrl + b 后按 $<ul><li>弹出重命名提示，允许你为当前会话指定一个更易于识别的名称。</li></ul></li><li>列出所有会话：Ctrl + b 后按 s<ul><li>显示当前所有会话的列表，便于选择并切换到其他会话。</li></ul></li></ul><p><strong>会话内和会话外命令的区别</strong></p><ul><li><p>会话外命令：这些命令是在终端中直接输入 tmux 命令（如 tmux new -s &lt;会话名&gt;）来创建、恢复或删除会话。它们通常用于管理会话的整体结构和操作，适合在 tmux 之外进行会话的创建和删除。</p></li><li><p>会话内命令：当你已经进入 tmux 会话后，可以通过前缀键（默认是 Ctrl + b）激活命令模式。例如，按 <code>&lt;prefix&gt; + ? </code> 可以查看帮助信息。会话内命令主要用于窗口和面板的管理，例如切换窗格、重命名窗口等，便于在会话中高效操作。</p></li><li><p>命令模式快捷键：在 tmux 中，使用 <code>&lt;prefix&gt; + :</code> 快捷键可以迅速进入命令输入模式，这与在普通终端中直接输入 tmux 命令相同。通过这种方式，你可以在当前会话中执行各种 tmux 命令，无需退出会话，从而提升工作效率。</p></li></ul><h3 id="2-2-2-窗口和面板快捷键"><a href="#2-2-2-窗口和面板快捷键" class="headerlink" title="2.2.2 窗口和面板快捷键"></a>2.2.2 窗口和面板快捷键</h3><p><strong>新建和管理窗口</strong></p><ul><li><p>新建窗口：Ctrl + b，c</p><ul><li>这个命令会在当前会话中创建一个新的窗口，便于开展新任务。</li></ul></li><li><p>重命名窗口：Ctrl + b，,</p><ul><li>此操作允许用户为当前窗口指定一个更易于识别的名称，适合用于标记任务或项目。</li></ul></li><li><p>删除窗口：Ctrl + b，&amp;</p></li><li><p>切换窗口：</p><ul><li>下一个窗口：Ctrl + b，n</li><li>上一个窗口：Ctrl + b，p</li><li>指定窗口：Ctrl + b，数字</li><li>选择窗口列表：Ctrl + b，w<ul><li>显示所有窗口的列表，便于选择并切换到特定窗口。</li></ul></li></ul></li></ul><p><strong>分割窗口为面板</strong><br>虽然 Kali Linux 自带的终端也支持分屏功能，但 tmux 的分屏功能更加灵活和强大。通过分割窗口，可以在同一屏幕中显示多个任务，支持以下分割方式：</p><ul><li><p>水平分割：Ctrl + b ，”</p></li><li><p>垂直分割：Ctrl + b ， %<br>为了更方便地记忆，可以将分割命令重新绑定为更直观的快捷键（文末有完整配置文件分享哦~）：</p><p>  bind | split-window -h  # 水平分割<br>  bind - split-window -v  # 垂直分割</p></li></ul><p>只需按 Ctrl + b 后再按 | 或 -，即可快速在窗口内进行水平或垂直分割。</p><p>建议布局：可以先水平分割，再进行垂直分割，根据实际工作需要灵活调整面板布局，形成符合个人操作习惯的分屏风格。</p><p><strong>切换面板</strong><br>在多个面板间的切换操作简便而高效：</p><ul><li>方向键切换：Ctrl + b，然后使用方向键选择目标面板</li><li>快速切换：Ctrl + b，o<ul><li>在面板间循环切换，适合快速浏览各个面板。</li></ul></li></ul><p><strong>面板放大与恢复</strong><br>当某个面板需要更大空间进行操作时，可以将其放大为全屏，再切换回来：</p><ul><li>放大&#x2F;恢复面板：Ctrl + b，z<br>这个命令可以让当前面板填满整个窗口，便于专注于重要任务。</li></ul><p><strong>调整面板大小</strong><br>在多面板布局下，调整面板的大小以满足不同的工作需求：</p><ul><li>常规调节：Ctrl + b，Alt + 方向键</li><li>精细调节：Ctrl + b，Ctrl + 方向键</li></ul><p><strong>关闭面板</strong><br>关闭面板：在目标面板中输入 exit 并回车，即可关闭当前面板。</p><ul><li>快速关闭当前面板：Ctrl + b，x</li></ul><h2 id="2-3-分屏状态下的内容复制问题"><a href="#2-3-分屏状态下的内容复制问题" class="headerlink" title="2.3 分屏状态下的内容复制问题"></a>2.3 分屏状态下的内容复制问题</h2><ul><li><p>鼠标复制：按住 Shift 键并用鼠标选择内容，选中后可右键或使用 Ctrl + Shift + C 完成复制。</p></li><li><p>全屏复制：当窗口内存在多个面板时，复制操作可能会包括其他面板内容。为避免这种情况，可先将目标面板放大（Ctrl + b, z），执行复制后再按 Ctrl + b, z 恢复面板原状。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1 安装&quot;&gt;&lt;/a&gt;1 安装&lt;/h1&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/kaliTool/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="kaliTool" scheme="http://suzi007.github.io/tags/kaliTool/"/>
    
  </entry>
  
  <entry>
    <title>远程管理控制工具集</title>
    <link href="http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/"/>
    <id>http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/%E8%BF%9C%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E9%9B%86%E5%90%88/</id>
    <published>2024-04-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:23:48.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-开源远程管理控制"><a href="#1-开源远程管理控制" class="headerlink" title="1 开源远程管理控制"></a>1 开源远程管理控制</h1><ul><li><p><a href="https://github.com/cobbr/Covenant">https://github.com/cobbr/Covenant</a> 红队协作的.NET C2框架</p></li><li><p><a href="https://github.com/byt3bl33d3r/SILENTTRINITY">https://github.com/byt3bl33d3r/SILENTTRINITY</a> 由<a href="http://www.xiaodi8.com/?tags=9">python</a>和.NET DLR写的C2框架</p></li><li><p><a href="https://github.com/malwaredllc/byob">https://github.com/malwaredllc/byob</a> 僵尸网络生成框架</p></li><li><p><a href="https://github.com/panda-re/lava">https://github.com/panda-re/lava</a> 大规模向程序中植入恶意程序</p></li><li><p><a href="https://github.com/proxycannon/proxycannon-ng">https://github.com/proxycannon/proxycannon-ng</a> 构建攻击僵尸网络</p></li><li><p><a href="https://github.com/deadPix3l/CryptSky/">https://github.com/deadPix3l/CryptSky/</a> 勒索软件</p></li><li><p><a href="https://github.com/jgamblin/Mirai-Source-Code">https://github.com/jgamblin/Mirai-Source-Code</a> C.MIRAI蠕虫病毒.6K。</p></li><li><p><a href="https://github.com/NYAN-x-CAT/Lime-RAT">https://github.com/NYAN-x-CAT/Lime-RAT</a> VB.勒索病毒</p></li><li><p><a href="https://github.com/The404Hacking/AndroRAT">https://github.com/The404Hacking/AndroRAT</a> JAVA.Android平台一对多带界面。</p></li><li><p><a href="https://github.com/AhMyth/AhMyth-Android-RAT">https://github.com/AhMyth/AhMyth-Android-RAT</a> Smali.Android平台一对多带界面。goodjob。</p></li><li><p><a href="https://github.com/BlackHacker511/BlackRAT">https://github.com/BlackHacker511/BlackRAT</a> JAVA.跨平台</p></li><li><p><a href="https://github.com/tiagorlampert/CHAOS">https://github.com/tiagorlampert/CHAOS</a> GO.win远控，可过大部分杀软。welljob。</p></li><li><p><a href="https://github.com/Ne0nd0g/merlin">https://github.com/Ne0nd0g/merlin</a> GO.c2通讯，多session</p></li><li><p><a href="https://github.com/0x09AL/Browser-C2">https://github.com/0x09AL/Browser-C2</a> GO.利用chrome以浏览器的形式连接C2服务器</p></li><li><p><a href="https://github.com/Tiked/Client">https://github.com/Tiked/Client</a> GO.Windows, OS X and linux RAT client</p></li><li><p><a href="https://github.com/yuanyuanxiang/SimpleRemoter">https://github.com/yuanyuanxiang/SimpleRemoter</a> C++&#x2F;C.基于大灰狼gh0st的远程控制器</p></li><li><p><a href="https://github.com/xdnice/PCShare">https://github.com/xdnice/PCShare</a> C++.远程控制软件，可以监视目标机器屏幕、注册表、文件系统等。0.2k。</p></li><li><p><a href="https://github.com/quasar/QuasarRAT">https://github.com/quasar/QuasarRAT</a> C#.一对多，界面。goodjob。2.4k。</p></li><li><p><a href="https://github.com/TheM4hd1/Vayne-RaT">https://github.com/TheM4hd1/Vayne-RaT</a> C#.一对多，界面</p></li><li><p><a href="https://github.com/TheSph1nx/RT-101">https://github.com/TheSph1nx/RT-101</a> C#.一对多，界面</p></li><li><p><a href="https://github.com/NYAN-x-CAT/AsyncRAT-C-Sharp">https://github.com/NYAN-x-CAT/AsyncRAT-C-Sharp</a> C#.一对多，界面</p></li><li><p><a href="https://github.com/DannyTheSloth/VanillaRat">https://github.com/DannyTheSloth/VanillaRat</a> C#.SIMPLE，界面</p></li><li><p><a href="https://github.com/brunull/pace">https://github.com/brunull/pace</a> C#.SIMPLE，界面</p></li><li><p><a href="https://github.com/5alt/ZeroRAT">https://github.com/5alt/ZeroRAT</a> powershell.windows上的一句话远控，只需要执行一条指令不需要写文件</p></li><li><p><a href="https://github.com/nettitude/PoshC2">https://github.com/nettitude/PoshC2</a> PowerShell\C#.远控工具，有win<a href="http://www.xiaodi8.com/?tags=38">提权</a>组件</p></li><li><p><a href="https://github.com/mwsrc/njRAT">https://github.com/mwsrc/njRAT</a> VB.源码</p></li><li><p><a href="https://github.com/euphrat1ca/njRAT-v0.7d">https://github.com/euphrat1ca/njRAT-v0.7d</a> vb.常见蠕虫远控，有很多变种，多session带界面</p></li><li><p><a href="https://github.com/peterpt/fuzzbunch">https://github.com/peterpt/fuzzbunch</a> PY2.方程式NSA漏洞利用远控RAT，配有自动化安装脚本与gui界面。永恒之蓝、永恒浪漫、永恒冠军、双星脉冲</p></li><li><p><a href="https://github.com/n1nj4sec/pupy">https://github.com/n1nj4sec/pupy</a> PY.Windows， Linux， OSX， Android跨平台，多session。groodjob。4.7k。</p></li><li><p><a href="https://github.com/nathanlopez/Stitch">https://github.com/nathanlopez/Stitch</a> PY.Windows、Mac OSX、Linux跨平台。welljob。1.3k。</p></li><li><p><a href="https://github.com/zerosum0x0/koadic">https://github.com/zerosum0x0/koadic</a> PY3.大宝剑利用JScript&#x2F;VBScript 进行控制，在内存中运行shell.GOODJOB。1.2K。</p></li><li><p><a href="https://github.com/Mr-Un1k0d3r/ThunderShell">https://github.com/Mr-Un1k0d3r/ThunderShell</a> PY2.CLI与web端，内存加载，RC4加密HTTP传输</p></li><li><p><a href="https://github.com/Ridter/MyJSRat">https://github.com/Ridter/MyJSRat</a> PY2.利用js后门，配合chm、hta可实现很多后门方式。evi1cg.me&#x2F;archives&#x2F;chm_backdoor.html。w</p></li><li><p><a href="https://github.com/EmpireProject/Empire">https://github.com/EmpireProject/Empire</a> Empire这是一个基于 poweshell 的命令执行框架，可以完成大部分<a href="http://www.xiaodi8.com/?tags=15">内网</a>渗透中所需要的功能。</p></li><li><p><a href="https://github.com/byt3bl33d3r/gcat">https://github.com/byt3bl33d3r/gcat</a> Gcat这个工具可以使用 gmail 作为 C&amp;C 服务器，是用 python 开发的。</p></li><li><p><a href="https://github.com/trustedsec/trevorc2">https://github.com/trustedsec/trevorc2</a> TrevorC2这个工具可以自定义网站，将控制的命令和参数隐藏在网页源代码中，这样更加隐蔽，不容易被人察觉。</p></li><li><p><a href="https://github.com/1ookup/trochilus">https://github.com/1ookup/trochilus</a> Trochilus（蜂鸟）木马，支持TCP，UDP，HTTP，HTTPS、用C ++编写（使用VS2010）</p></li></ul><h1 id="2-多协议远控shell"><a href="#2-多协议远控shell" class="headerlink" title="2 多协议远控shell"></a>2 多协议远控shell</h1><ul><li><p><a href="https://blog.csdn.net/Fly_hps/article/list/8?/">https://blog.csdn.net/Fly_hps&#x2F;article&#x2F;list&#x2F;8?&#x2F;</a> FLy_鹏程万里【基础篇】———— 隐匿攻击之</p></li><li><p><a href="https://github.com/inquisb/icmpsh">https://github.com/inquisb/icmpsh</a> C.Simple reverse ICMP shell</p></li><li><p><a href="https://github.com/jamesbarlow/icmptunnel/">https://github.com/jamesbarlow/icmptunnel/</a> C.构建icmp隧道</p></li><li><p><a href="https://github.com/iagox86/dnscat2">https://github.com/iagox86/dnscat2</a> RUBY&#x2F;C.cs结构，利用DNS协议进行端对端传输</p></li><li><p><a href="https://github.com/ahhh/Reverse_DNS_Shell">https://github.com/ahhh/Reverse_DNS_Shell</a> PY.通过dns传输</p></li><li><p><a href="https://github.com/Coalfire-Research/Slackor">https://github.com/Coalfire-Research/Slackor</a> GO,PY3.基于slack框架命令控制，利用dns服务通讯。集成spookflare&#x2F;impacket&#x2F;pypykatz。simple。goodjob。</p></li></ul><h1 id="3-商业版"><a href="#3-商业版" class="headerlink" title="3 商业版"></a>3 商业版</h1><ul><li><p><a href="https://cobaltstrike.com/">https://cobaltstrike.com/</a> <a href="http://www.xiaodi8.com/?tags=39">Cobalt Strike</a> 这个工具在实际的攻击活动中应用广泛，有很好的操作界面，功能强大，有非常多的渗透测试人员使用。</p></li><li><p><a href="https://github.com/rapid7/metasploit-framework">https://github.com/rapid7/metasploit-framework</a> Metasploit Framework 这是国内外都非常出名，使用非常广泛的集漏洞扫描与利用于一身的渗透测试框架。</p></li></ul><h1 id="4-协议分析"><a href="#4-协议分析" class="headerlink" title="4 协议分析"></a>4 协议分析</h1><ul><li><p><a href="https://www.freebuf.com/articles/paper/167917.html">https://www.freebuf.com/articles/paper/167917.html</a> Gh0st大灰狼RAT家族通讯协议分析</p></li><li><p><a href="https://www.freebuf.com/articles/terminal/184930.html">https://www.freebuf.com/articles/terminal/184930.html</a> 新Njrat木马（Bladabindi）的新功能源码分析</p></li><li><p><a href="https://www.freebuf.com/articles/network/122244.html">https://www.freebuf.com/articles/network/122244.html</a> 史上最全的njRAT通信协议分析</p></li><li><p><a href="https://www.anquanke.com/post/id/182122">https://www.anquanke.com/post/id/182122</a> 分析一款远控木马的通讯机制</p></li><li><p><a href="https://www.anquanke.com/post/id/184263">https://www.anquanke.com/post/id/184263</a> 分析asyncRAT远控的数据包格式及通讯建立过程</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-开源远程管理控制&quot;&gt;&lt;a href=&quot;#1-开源远程管理控制&quot; class=&quot;headerlink&quot; title=&quot;1 开源远程管理控制&quot;&gt;&lt;/a&gt;1 开源远程管理控制&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/c</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="安全工具集" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux基线检查工具-Python</title>
    <link href="http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/%E5%9F%BA%E7%BA%BF%E5%B7%A5%E5%85%B7/Linux%E5%9F%BA%E7%BA%BF%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7-Python/"/>
    <id>http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/%E5%9F%BA%E7%BA%BF%E5%B7%A5%E5%85%B7/Linux%E5%9F%BA%E7%BA%BF%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7-Python/</id>
    <published>2024-04-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:30:16.021Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>aqjxpz 工具是基于 python 语言开发的工具，主要针对 Linux 进行进行基线检测。主要针对 Linux 6&#x2F;7 的操作系统做基线检查和配置，其他版本系统可能部分检测无效。</p></blockquote><blockquote><p>主要功能包括如下：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;1、账号管理&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line">NO1.1、【配置要求】：删除或锁定无关的系统用户和用户组；</span><br><span class="line">基线符合性判断依据:判断是否为常规用户，具体系统无关用户，根据运维人员确定(脚本通过匹配系统用户和运维用户字典,对无关用户进行锁定。)</span><br><span class="line">       </span><br><span class="line">NO1.2、【配置要求】：检查是否存在除root之外UID为0的用户</span><br><span class="line">基线符合性判断依据:执行命令awk -F &#x27;:&#x27;  &#x27;$3==0 &#123; print $1 &#125;&#x27; /etc/passwd 根据检查结果判断是否存在除root之外UID为0的用户，如存在锁定该用户passwd –l &lt;username&gt;    #锁定该用户</span><br><span class="line">       </span><br><span class="line">NO1.3、【配置要求】：登录超时设置</span><br><span class="line">基线符合性判断依据：判断是否配置&quot;TMOUT=&quot;,建议配置TMOUT=300,并且值不大于600</span><br><span class="line">       </span><br><span class="line">NO1.4、【配置要求】：限制管理员root远程登录</span><br><span class="line">基线符合性判断依据：设置/etc/ssh/sshd_config文件中，第一次出现PermitRootLogin no为准; 如存在PermitRootLogin yes改为PermitRootLogin no，并且检查/etc/ssh/sshd_config，是否存在：</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;2、口令管理配置要求说明&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line">NO2.1、【配置要求】：密码复杂度要求</span><br><span class="line">    1）采用数字、字母、符号的无规律混排方式；</span><br><span class="line">    2）口令的长度至少为8位，并且每90天至少更换1次</span><br><span class="line">    3）如果系统长度不支持上述口令复杂度要求，应使用所支持的最长长度并适当缩小更换周期；也可以使用动态密码卡等一次性口令认证方式。</span><br><span class="line">    4)修改操作系统账户的默认口令，系统无法实现的除外。</span><br><span class="line">基线符合性判断依据：执行命令cat /etc/pam.d/system-auth|grep  &quot;password requisite pam_cracklib.so difok=3 minlen=8 ucredit=-1 lcredit=-1 dcredit=-1 ocredit=-1&quot;是否存在。</span><br><span class="line"></span><br><span class="line">NO2.2、【配置要求】：禁止空口令登录</span><br><span class="line">检查方法：awk -F &#x27;:&#x27; &#x27;length($2)==0 &#123; print $1 &#125;&#x27; /etc/shadow；[空]:表示无空口令登录的用户,否则存在空口令用户将它锁住或删除。</span><br><span class="line"></span><br><span class="line">NO2.3、【配置要求】：检查是否设置口令最小长度[标准值10,建议配置12及以上]</span><br><span class="line">检查方法：查看文件/etc/login.defs中设置 PASS_MIN_LEN 不小于标准值（10）     </span><br><span class="line">NO2.4、【配置要求】密码更新周期和口令更改最小天数要求</span><br><span class="line">检查方法：检查/etc/login.defs参数， </span><br><span class="line">PASS_MAX_DAYS 90</span><br><span class="line">PASS_WARN_AGE 30</span><br><span class="line">PASS_MIN_DAYS 6</span><br><span class="line">[检查最长期限是否生效]passwd -S [USERNAME]|awk  &#x27;&#123; print $5 &#125;&#x27;</span><br><span class="line">[检查警告期限是否生效]passwd -S [USERNAME]|awk  &#x27;&#123; print $6&#125;&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;3、访问控制及认证授权&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line">NO3.1、【配置要求】：用户缺省访问权限</span><br><span class="line">控制用户缺省访问权限，当在创建新文件或目录时应屏蔽掉新文件或目录不应有的访问允许权限。防止同属于该组的其它用户及别的组的用户修改该用户的文件或更高限制。</span><br><span class="line">基线符合性判断依据：</span><br><span class="line">    1）执行：more /etc/profile检查是否包含 umask 值且 umask=027(同理/etc/csh.login、/etc/csh.cshrc、/etc/bashrc中查看umask 077)</span><br><span class="line">    2）如果没有执行：echo &quot;umask 027&quot; &gt;&gt; /etc/profile 或 echo &quot;umask 077&quot; &gt;&gt; /etc/csh.login等</span><br><span class="line">    </span><br><span class="line">NO3.2、【配置要求】：授权账户SSH访问控制</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;对于使用IP 协议进行远程维护的系统，应配置使用SSH 等加密协议，并安全配置SSHD 的设置。</span></span><br><span class="line">检查方法：在/etc/ssh/sshd_config配置文件中确认如下配置是否存在：</span><br><span class="line">    Protocol 2</span><br><span class="line">    LogLevel INFO</span><br><span class="line">    MaxAuthTries 5</span><br><span class="line">    IgnoreRhosts yes</span><br><span class="line">    RhostsAuthentication no</span><br><span class="line">    RhostsRSAAuthentication no</span><br><span class="line">    HostbasedAuthentication no</span><br><span class="line">    PermitEmptyPasswords no</span><br><span class="line">    PermitUserEnvironment no</span><br><span class="line">    ClientAliveInterval 60</span><br><span class="line">    ClientAliveCountMax 3</span><br><span class="line">    LoginGraceTime 60</span><br><span class="line">    X11Forwarding yes</span><br><span class="line">    配置之后,重启服务：service sshd restart</span><br><span class="line">    </span><br><span class="line">NO3.3、【配置要求】:允许和限制SSH远程访问主机</span><br><span class="line"><span class="meta prompt_"> &gt;</span><span class="language-bash">&gt;对物理主机/虚拟机进行IP地址访问限制，防止异常陌生IP地址访问攻击。</span></span><br><span class="line">    1）第一种方法（废弃）：</span><br><span class="line">    配置 /etc/hosts.deny 与 /etc/hosts.allow文件</span><br><span class="line">    配置 /etc/hosts.deny 文件</span><br><span class="line">    # no sshd </span><br><span class="line">    sshd:ALL  //禁止所有IP地址ssh访问</span><br><span class="line">    配置 /etc/hosts.allow 文件</span><br><span class="line">    根据业务需求配置相关IP地址</span><br><span class="line">    例如：sshd:192.168.220.   //允许192.168.220.0  IP段访问</span><br><span class="line">    2）第二种方法（推荐）:</span><br><span class="line">    /etc/ssh/sshd_config</span><br><span class="line">    allowusers [username]@[IP或IP段]</span><br><span class="line">    特殊说明：第一种方法不一定完全生效，脚本只对第二种配置进行检查，第一种配置是不符合规范的。</span><br><span class="line">                   </span><br><span class="line">NO3.4、【配置要求】登录失败处理功能策略(不做检查，此方法存在争议)</span><br><span class="line">设置登录失败功能，建议设置5次，防止恶意攻击者可以对系统口令进行反复暴力破解(设置登录失败功能策略，通过PAM限制用户登录失败次数，如果次数达到设置的阈值，则锁定用户)</span><br><span class="line">检查方法：</span><br><span class="line">    1)vim /etc/pam.d/sshd （远程ssh）</span><br><span class="line">    在文件首行#%PAM-1.0下增加：</span><br><span class="line">    auth required pam_tally2.so deny=5 unlock_time=600 even_deny_root root_unlock_time=600</span><br><span class="line">    2)vim /etc/pam.d/login （终端）</span><br><span class="line">    在文件首行#%PAM-1.0下增加：</span><br><span class="line">    auth required pam_tally2.so deny=5 unlock_time=600 even_deny_root root_unlock_time=600</span><br><span class="line">    3)vim /etc/pam.d/system-auth (服务器终端)</span><br><span class="line">    在文件首行#%PAM-1.0下增加：</span><br><span class="line">    auth required pam_tally2.so onerr=fail deny=5 unlock_time=600 even_deny_root root_unlock_time=600</span><br><span class="line">    </span><br><span class="line">NO3.5、【配置要求】检查是否使用PAM认证模块禁止wheel组之外的用户su为root</span><br><span class="line">为了安全性，只允许部分普通用户能切换到root，其他用户做限制不能切换</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;4、重要目录和文件权限设置&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"> </span><br><span class="line">NO4.1、【配置要求】：配置重要目录和文件的权限</span><br><span class="line">    控制用户对有敏感标记重要信息资源的操作。</span><br><span class="line">    检查方法：</span><br><span class="line">    ls –l /etc/  [不做检查，配置之后存在异常]</span><br><span class="line">    ls -l /etc/passwd</span><br><span class="line">    ls -l /etc/group </span><br><span class="line">    ls -l /etc/shadow </span><br><span class="line">    ls -l /etc/services </span><br><span class="line">    ls -l /etc/security </span><br><span class="line">    ls -l /etc/rc*.d/ </span><br><span class="line">    ls -l /etc/rc.d/init.d/</span><br><span class="line">    按照如下建议修改</span><br><span class="line">    chmod 750 /etc  #(由于会影响普通用户家目录[chmod 755 /etc/])</span><br><span class="line">    chmod 750 /tmp  #(如果安装图形界面 chmod 777 /tmp，否则会报错&quot;服务器有错/usr/libexec/gconf-sanity-check-2的退出状态为256)</span><br><span class="line">    chmod 750 /etc/rc.d/init.d</span><br><span class="line">    chmod 644 /etc/passwd</span><br><span class="line">    chmod 644 /etc/group </span><br><span class="line">    chmod 400 /etc/shadow </span><br><span class="line">    chmod 644 /etc/services </span><br><span class="line">    chmod 600 /etc/security </span><br><span class="line">    chmod 750 /etc/rc*.d/ </span><br><span class="line">    chmod 750 /etc/rc.d/init.d</span><br><span class="line">    对于重要目录，建议执行如下类似操作：chmod  750 /etc/rc.d/init.d/*；只有 root 可以读、写和执行这个目录下的脚本</span><br><span class="line">    </span><br><span class="line">NO4.2、【配置要求】：检查重要文件是否存在suid和sgid权限</span><br><span class="line">为降低风险，防止未授权用户通过sudo执行相关重要文件命令</span><br><span class="line">检查方法：</span><br><span class="line">执行命令: </span><br><span class="line">find /usr/bin/chage /usr/bin/gpasswd /usr/bin/wall /usr/bin/chfn /usr/bin/chsh /usr/bin/newgrp /usr/bin/write /usr/sbin/usernetctl /usr/sbin/traceroute /bin/mount /bin/umount /bin/ping /sbin/netreport -type f -perm +6000 2&gt;/dev/null </span><br><span class="line">如果存在输出结果，则使用chmod 755 文件名 命令修改文件的权限。 </span><br><span class="line">例如：chmod a-s /usr/bin/chage</span><br><span class="line">       </span><br><span class="line">NO4.3、【配置要求】：检查系统引导器配置文件权限</span><br><span class="line">    为降低风险，检查系统引导器配置文件权限</span><br><span class="line">    检查方法：</span><br><span class="line">    查看如下文件权限是否为600</span><br><span class="line">    #Linux6</span><br><span class="line">    chmod 600 /etc/grub.conf [非链接文件]</span><br><span class="line">    chmod 600 /boot/grub/grub.conf</span><br><span class="line">    chmod 600 /etc/lilo.conf</span><br><span class="line">    #Linux7</span><br><span class="line">    chmod 600 /etc/grub2.cfg [非链接文件]</span><br><span class="line">    chmod 600 /boot/grub2/grub.cfg</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;5、日志审核&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line">NO5.1、【配置要求】：开启系统日志记录</span><br><span class="line">应开启主机操作系统审核功能，审核内容包括但不限于运行状态日志、系统事件、账户管理、登录事件、操作事件、配置文件的修改，日志保存期限至少6个月。</span><br><span class="line">检查方法：</span><br><span class="line">    1)查看日志服务是否安装并且进程是否已启动：</span><br><span class="line">    rpm -qa|grep rsyslog</span><br><span class="line">    ps -elf |grep rsyslogd</span><br><span class="line">    2)开启日志审核：</span><br><span class="line">    /etc/init.d/rsyslog start</span><br><span class="line">    或service rsyslog start</span><br><span class="line">    3)日志加固，确保已配置rsyslog默认文件权限：</span><br><span class="line">    vim /etc/rsyslog.conf</span><br><span class="line">    在#### GLOBAL DIRECTIVES ####段中添加：</span><br><span class="line">    $FileCreateMode 0640</span><br><span class="line">    </span><br><span class="line">NO5.2、【配置要求】：开启操作日志记录，记录用户的操作日志。</span><br><span class="line">应开启主机操作系统审核功能，审核内容包括但不限于运行状态日志、系统事件、账户管理、登录事件、操作事件、配置文件的修改，日志保存期限至少6个月。</span><br><span class="line">检查方法：在/etc/profile中检查是否存在如下配置</span><br><span class="line"></span><br><span class="line">NO5.3、【配置要求】：检查日志文件权限设置</span><br><span class="line">设备应配置权限，控制对日志文件读取、修改和删除等操作(权限小于等于775)</span><br><span class="line">［检查方法］</span><br><span class="line">    %s 文件权限权限小于等于775,建议设置600</span><br><span class="line">    [加固建议]</span><br><span class="line">    chmod 600 /var/log/cron </span><br><span class="line">    chmod 600 /var/log/secure </span><br><span class="line">    chmod 600 /var/log/messages </span><br><span class="line">    chmod 600 /var/log/maillog </span><br><span class="line">    chmod 600 /var/log/boot.log </span><br><span class="line">    chmod 600 /var/log/mail </span><br><span class="line">    chmod 600 /var/log/localmessages </span><br><span class="line">    chmod 600 /var/log/spooler </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;6、安全管理&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line">NO6.1、【配置要求】：关闭不必要的服务和端口</span><br><span class="line">关闭telnet、autofs、acpid、cpus、ipsec、ip6tables、rpcbind、postfix等服务</span><br><span class="line">检查方法：</span><br><span class="line">    chkconfig --list |grep 3:on 查看哪些正运行的服务</span><br><span class="line">    Linux6:</span><br><span class="line">    使用下面命令关闭无关的服务：</span><br><span class="line">        chkconfig --level 12345 autofs off</span><br><span class="line">        chkconfig --level 12345 acpid off</span><br><span class="line">        chkconfig --level 12345 cups off </span><br><span class="line">        chkconfig --level 12345 cups-config-daemon off</span><br><span class="line">        chkconfig --level 12345 ipsec off</span><br><span class="line">        chkconfig --level 12345 ip6tables off</span><br><span class="line">        chkconfig --level 12345 rpcbind off</span><br><span class="line">        chkconfig --level 12345 postfix off</span><br><span class="line">        chkconfig --level 12345 pppoe-server off</span><br><span class="line">        chkconfig --level 12345 sendmail off</span><br><span class="line">        chkconfig --level 12345 isdn off</span><br><span class="line">        chkconfig --level 12345 mdmonitor off</span><br><span class="line">        chkconfig --level 12345 rhnsd off</span><br><span class="line">        chkconfig --level 12345 smartd off</span><br><span class="line">        chkconfig --level 12345 gpm off</span><br><span class="line">        chkconfig --level 12345 telnet off</span><br><span class="line">        chkconfig --level 12345 nfslock off</span><br><span class="line">    Linux7:</span><br><span class="line">        systemctl list-unit-files|grep enabled|awk -F &#x27;.&#x27; &#x27;&#123; print $1&#125;&#x27;</span><br><span class="line">    关闭以上服务 systemctl disable [服务名称]</span><br><span class="line">    </span><br><span class="line">NO6.2、【配置要求】：互联网DMZ区服务器开启iptables服务</span><br><span class="line">对于检查互联网服务器IP为%s进行防火墙状态和规则检查</span><br><span class="line">检查方法：</span><br><span class="line">    1)检查iptables是否安装或firewalld服务状态。</span><br><span class="line">    rpm –qa|grep iptables 或 rpm –qa|grep firewalld</span><br><span class="line">    2)安装完成后查询iptables或firewalld服务是否运行：</span><br><span class="line">    service iptables status  或 systemctl status firewalld          </span><br><span class="line">NO6.3、【配置要求】：按安全组检查安全狗软件是否安装</span><br><span class="line">对操作系统操作审计。</span><br><span class="line">检查方法：</span><br><span class="line">    1)检查safedog服务状态。</span><br><span class="line">    service safedog status</span><br><span class="line">    2)查看到控制中心端口80端口是否能通：</span><br><span class="line">    telnet 10.116.124.65 80 </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;7、系统优化与运维管理&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line">NO7.1、【配置要求】：swappiness配置优化</span><br><span class="line">[检查方法]</span><br><span class="line">    cat /proc/sys/vm/swappiness值是否&lt;=10，建议配置为10。</span><br><span class="line">[加固建议]</span><br><span class="line">    echo &quot;vm.swappiness=10&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">    sysctl -p</span><br><span class="line">    cat /proc/sys/vm/swappiness</span><br><span class="line">NO7.2、【配置要求】：建立系统维护账号和建立互信</span><br><span class="line">用于普通用户或root无法登录出现异常时候，通过此账号进行维护处理。</span><br><span class="line">[检查方法]</span><br><span class="line">检查是否存在xtyw账号，过期时间是否设置为永不过期，互信密钥是否添加，sudoer配置文件是否添加</span><br><span class="line">    检查用户是否存在：id xtyw</span><br><span class="line">    检查用户是否设置密码：passwd -S xtyw|awk &#x27;&#123; print $2 &#125;&#x27;&quot; [P或PS:正常状态,L或LK：为锁定状态,NP:用户密码未空的状态]</span><br><span class="line">    检查是否设置为永不过期：passwd -S xtyw</span><br><span class="line">    检查是否设置为互信：首先判断：/home/xtyw/.ssh/authorized_keys文件是否存在，然后检查cat /home/xtyw/.ssh/authorized_keys|grep &#x27;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC1wYTh7cw1lUBcgr5kMKtLilh3CwbxhCJDITgZfYDlbNtPiURtrvpamBMHMYz9EuuBmXyXSF9D18oD/HmFiIXzgqobTGw2asNxwbpoPBY1YxvHJAZUV99ml/GrqdIFbLW2lgDsojIkXA0rnxZ1G/uHOaZBPuKKnvlaXyhtMV4NdZFK3UuzDyz82Bx8FLGVo+clkkZ9BeOWyOrTi5ihk/6ime24WdiSue2XwXxjrGCSu4oKBDNj778ytl31HSUz14gBrH4em1nLM22+P6ddVhrKp4oJgvY7IqAG1ibhuxUNXWkf3Q5EM5ZKdchK9TCKdKhiFqwGgiCmQAonjRD8Cx9H xtyw@hxq-poller21&#x27;</span><br><span class="line">    检查是否设置sudoers：grep -iE &#x27;xtyw    ALL=\(ALL\)  NOPASSWD:ALL&#x27; /etc/sudoers</span><br><span class="line">[加固建议]</span><br><span class="line">    useradd  xtyw</span><br><span class="line">    echo `&lt; /dev/urandom tr -dc 0-9-A-Z-a-z-/|head -c $&#123;1:-16&#125;;echo`|passwd --stdin xtyw</span><br><span class="line">    chage -M 99999 xtyw</span><br><span class="line">    mkdir /home/xtyw/.ssh</span><br><span class="line">    chmod  700 /home/xtyw/.ssh</span><br><span class="line">    echo &quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC1wYTh7cw1lUBcgr5kMKtLilh3CwbxhCJDITgZfYDlbNtPiURtrvpamBMHMYz9EuuBmXyXSF9D18oD/HmFiIXzgqobTGw2asNxwbpoPBY1YxvHJAZUV99ml/GrqdIFbLW2lgDsojIkXA0rnxZ1G/uHOaZBPuKKnvlaXyhtMV4NdZFK3UuzDyz82Bx8FLGVo+clkkZ9BeOWyOrTi5ihk/6ime24WdiSue2XwXxjrGCSu4oKBDNj778ytl31HSUz14gBrH4em1nLM22+P6ddVhrKp4oJgvY7IqAG1ibhuxUNXWkf3Q5EM5ZKdchK9TCKdKhiFqwGgiCmQAonjRD8Cx9H xtyw@hxq-poller21&quot; &gt;&gt;/home/xtyw/.ssh/authorized_keys</span><br><span class="line">    chmod 600 /home/xtyw/.ssh/authorized_keys</span><br><span class="line">    chown -R xtyw:xtyw /home/xtyw/.ssh</span><br><span class="line">    chmod u+w /etc/sudoers</span><br><span class="line">    sed -i &#x27;/^root/a xtyw    ALL=(ALL)  NOPASSWD:ALL&#x27;  /etc/sudoers</span><br><span class="line">               chmod u-w /etc/sudoers </span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;8、其他配置要求&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></span><br><span class="line"></span><br><span class="line">NO8.1、【配置要求】：检查是否设置ssh登录前警告Banner</span><br><span class="line">SSH登录时显示警告信息，在登录成功前不泄漏服务器信息。</span><br><span class="line">［检查方法］</span><br><span class="line">    查看文件/etc/ssh/sshd_config，检查是否存在如下配置:banner &lt;file_path&gt;，且&lt;file_path&gt;内容不为空</span><br><span class="line">［加固方法］</span><br><span class="line">   touch /etc/ssh_banner</span><br><span class="line">　　chown bin:bin /etc/ssh_banner</span><br><span class="line">　　chmod 644 /etc/ssh_banner</span><br><span class="line">　　echo &quot; Authorized only. All activity will be monitored and reported &quot; &gt; /etc/ssh_banner</span><br><span class="line">　　echo &quot;Banner /etc/ssh_banner&quot; &gt;&gt; /etc/ssh/sshd_config</span><br><span class="line">　　service sshd restart</span><br><span class="line">　　</span><br><span class="line">NO8.2、【配置要求】：检查是否修改SNMP默认团体字.</span><br><span class="line">SNMP服务未开启或者修改了默认的团体名则合规,否则不合规。</span><br><span class="line">［检查方法］</span><br><span class="line">　　1）查看snmpd进程是否存在。</span><br><span class="line"><span class="meta prompt_">　　#</span><span class="language-bash">ps -ef|grep <span class="string">&quot;snmpd&quot;</span>|grep -v <span class="string">&quot;grep&quot;</span></span></span><br><span class="line">　　2）查看文件/etc/snmp/snmpd.conf,检查SNMP团体名配置。</span><br><span class="line">［加固建议］</span><br><span class="line">１）修改snmp配置文件/etc/snmp/snmpd.conf找到类似如下配置,修改默认团体名public为其他用户自己可识别的字符串。</span><br><span class="line">com2sec notConfigUser  default  public   #&lt;notConfigUser&gt;为连接snmp的用户名 &lt;default&gt;为可以连接snmp的地址范围 &lt;public&gt;为团体名</span><br><span class="line">２）、重启snmp服务</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">service snmpd restart</span></span><br><span class="line"></span><br><span class="line">NO8.3、【配置要求】：检查系统是否禁用Ctrl+Alt+Delete组合键</span><br><span class="line">    禁止Ctrl+Alt+Delete，防止非法重新启动服务器。禁用了使用组合键Ctrl+Alt+Delete重启系统则合规,否则不合规</span><br><span class="line">［检查方法］</span><br><span class="line">Linux７：</span><br><span class="line">　　检查是否存在这个文件/usr/lib/systemd/system/ctrl-alt-del.target</span><br><span class="line">Linux６</span><br><span class="line">　　查看文件/etc/init/control-alt-delete.conf,是否存在使用组合键control+alt+delete控制系统重启的配置。</span><br><span class="line">exec /sbin/shutdown -r now &quot;Control-Alt-Delete pressed&quot;</span><br><span class="line">Linux5</span><br><span class="line">    查看/etc/inittab文件  </span><br><span class="line">    ca::ctrlaltdel:/sbin/shutdown -t3 -r now   //默认为启用，在前面加上#号进行关闭</span><br><span class="line">［加固建议］</span><br><span class="line">　Linux７：</span><br><span class="line">　ｍｖ　/usr/lib/systemd/system/ctrl-alt-del.target /usr/lib/systemd/system/ctrl-alt-del.target.bak</span><br><span class="line">　init　q　重新加载配置文件使配置生效或注释掉/usr/lib/systemd/system/ctrl-alt-del.target所有内容</span><br><span class="line">Linux 6</span><br><span class="line">　　编辑文件/etc/init/control-alt-delete.conf,将如下行删除或注释:</span><br><span class="line">　　exec /sbin/shutdown -r now &quot;Control-Alt-Delete pressed&quot;</span><br><span class="line">Linux 5</span><br><span class="line">　　编辑文件cat /etc/inittab,将如下行删除或注释:</span><br><span class="line">　　ca::ctrlaltdel:/sbin/shutdown -t3 -r now</span><br><span class="line">　　</span><br><span class="line">NO8.4、【配置要求】：主机须启用时钟同步</span><br><span class="line">对应区域配置对应NTP时间源：｛%s｝</span><br><span class="line">［检查方法］</span><br><span class="line">　　 1.确认是否安装NTP组件</span><br><span class="line">    rpm -qa|grep -E  &#x27;ntp-&#x27;</span><br><span class="line">    2.检查是否配置对应区域的时间源</span><br><span class="line">    server XXX.XXX.XXX.XXX</span><br><span class="line">    3、是否运行，然后是否自动启动</span><br><span class="line">    ps -fe|grep ntpd</span><br><span class="line">    Linux6</span><br><span class="line">    chkconfig --list ntpd </span><br><span class="line">    Linux7 </span><br><span class="line">    systemctl list-unit-files|grep enabled|awk -F &#x27;.&#x27; &#x27;&#123; print $1&#125;&#x27;|grep ntpd是否存在</span><br><span class="line">[加固建议]</span><br><span class="line">编辑/etc/ntp.conf文件，对NTP服务进行配置，可在文件中加一行：</span><br><span class="line">server XXX.XXX.XXX.XXX     #将时钟源指定为已设好的时钟同步服务器</span><br><span class="line">service ntpd start        #启用服务</span><br><span class="line">chkconfig ntpd on          #设置自动运行</span><br><span class="line"></span><br><span class="line">NO8.5、【配置要求】：禁用core dump </span><br><span class="line">core dump 中可能包括系统信息，易被入侵者利用。</span><br><span class="line">［检查方法］</span><br><span class="line">　　　1)执行：more /etc/security/limits.conf 检查是否包含下列项：</span><br><span class="line">     * soft core 0</span><br><span class="line">     * hard core 0</span><br><span class="line">     2)若没有，执行：vi /etc/security/limits.conf 添加</span><br><span class="line">     * soft core 0</span><br><span class="line">     * hard core 0 </span><br><span class="line">     [加固建议]</span><br><span class="line">     echo &quot;* soft core 0&quot; &gt;&gt; /etc/security/limits.conf</span><br><span class="line">     echo &quot;* hard core 0&quot; &gt;&gt; /etc/security/limits.conf</span><br><span class="line">     </span><br><span class="line">NO8.6、【配置要求】：用户使用最大进程数及文件打开数配置</span><br><span class="line">建议根据业务需求对单个用户使用的进程数、文件打开数等进行设置。</span><br><span class="line">［检查方法］</span><br><span class="line">    脚本通过检查操作系统是否存在%s,对用户是否全部配置 /etc/security/limits.conf进行检查。</span><br><span class="line">[加固建议]</span><br><span class="line">    vi /etc/security/limits.conf 添加</span><br><span class="line">    *   soft    nproc     65535(后面值根据业务情设定)</span><br><span class="line">    *   hard    nproc     65535</span><br><span class="line">    *   soft    nofile    65535</span><br><span class="line">    *   hard    nofile    65535 </span><br><span class="line">    重新ssh连接建立会话ulimit -a检查是否生效。</span><br><span class="line">    </span><br><span class="line">NO8.7、【配置要求】：系统服务优先级配置</span><br><span class="line">当系统服务水平降低时，通过renice命令修改已经存在进程的NI值</span><br><span class="line">［检查方法］</span><br><span class="line">    检查/etc/sudoers中是否存在[%s]  ALL=(ALL) NOPASSWD:/usr/bin/renice </span><br><span class="line">    检查方式：cat /etc/sudoers|grep -v &#x27;^#&#x27;|grep &#x27;NOPASSWD:/usr/bin/renice&#x27;</span><br><span class="line">[加固建议]</span><br><span class="line">    1)、配置以weblogic用户为例能够sudo执行renice 命令，在/etc/sudoers 文件中添加</span><br><span class="line">    例如：weblogic  ALL=(ALL) NOPASSWD:/usr/bin/renice</span><br><span class="line">                    </span><br><span class="line">    2)、用top和ps aux 命令查看存在进程的NI值和进程号 </span><br><span class="line">    3)、手动修改已经存在进程的NI值</span><br><span class="line">        renice -n -15  -p &#123;weblogic pid&#125;  -n后面是优先级的值，-p后面是进程号</span><br><span class="line">        </span><br><span class="line">NO8.8、【配置要求】：检查/etc/aliases是否禁用不必要的别名</span><br><span class="line">　　　　　　　　检查/etc/aliases是否禁用不必要的别名</span><br><span class="line">　　　     　　［检查方法］</span><br><span class="line">                编辑别名文件vi /etc/aliases，删除或注释掉下面的行</span><br><span class="line">                #games: root</span><br><span class="line">                #ingres: root</span><br><span class="line">                #system: root</span><br><span class="line">                #toor: root</span><br><span class="line">                #uucp: root</span><br><span class="line">                #manager: root</span><br><span class="line">                #dumper: root</span><br><span class="line">                #operator: root</span><br><span class="line">                #decode: root</span><br><span class="line">                #root: marc</span><br><span class="line">                补充操作说明</span><br><span class="line">                更新后运行/usr/bin/newaliases，使改变生效 </span><br><span class="line">                [加固建议]</span><br><span class="line">                sed  -i &#x27;/^games/s/^/#/g&#x27; /etc/aliases</span><br><span class="line">                sed  -i &#x27;/^ingres/s/^/#/g&#x27; /etc/aliases</span><br><span class="line">                sed  -i &#x27;/^system/s/^/#/g&#x27; /etc/aliases</span><br><span class="line">                sed  -i &#x27;/^toor/s/^/#/g&#x27; /etc/aliases</span><br><span class="line">                sed  -i &#x27;/^uucp/s/^/#/g&#x27; /etc/aliases</span><br><span class="line">                sed  -i &#x27;/^manager/s/^/#/g&#x27; /etc/aliases</span><br><span class="line">                sed  -i &#x27;/^dumper/s/^/#/g&#x27; /etc/aliases</span><br><span class="line">                sed  -i &#x27;/^operator/s/^/#/g&#x27; /etc/aliases</span><br><span class="line">                sed  -i &#x27;/^decode/s/^/#/g&#x27; /etc/aliases</span><br><span class="line">                sed  -i &#x27;/^root/s/^/#/g&#x27; /etc/aliases</span><br><span class="line">                /usr/bin/newaliases </span><br><span class="line">                    </span><br><span class="line">NO8.9、【配置要求】：检查是否配置定时自动屏幕锁定（适用于具备图形界面的设备）</span><br><span class="line">检查是否配置定时自动屏幕锁定（只对安装了图形界面系统生效）</span><br><span class="line">［检查方法］</span><br><span class="line">    检查是否安装GConf2</span><br><span class="line">    rpm -qa|grep GConf2</span><br><span class="line"></span><br><span class="line">NO8.10、【配置要求】：检查密码重复使用次数限制</span><br><span class="line">对于采用静态口令认证技术的设备，应配置设备，使用户不能重复使用最近5次（含5次）内已使用的口令。</span><br><span class="line">［检查方法］</span><br><span class="line">    检查/etc/pam.d/system-auth中是否存在password sufficient pam_unix.so md5 shadow nullok try_first_pass use_authtok remember=5</span><br><span class="line">[加固建议]</span><br><span class="line">    sed -i &#x27;/try_first_pass use_authtok/s/sha512/md5/g&#x27; /etc/pam.d/system-auth</span><br><span class="line">    sed -i &#x27;/try_first_pass use_authtok/s/$/ remember=5/g&#x27; /etc/pam.d/system-auth</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">NO8.11、【配置要求】：检查系统内核参数配置</span><br><span class="line">检查系统内核参数配置</span><br><span class="line">[检查方法]</span><br><span class="line">    检查是否禁止icmp源路由(0):cat /proc/sys/net/ipv4/conf/all/accept_source_route</span><br><span class="line">    检查是否禁止icmp重定向报文(0):cat /proc/sys/net/ipv4/conf/all/accept_redirects</span><br><span class="line">    检查send_redirects配置(0):cat /proc/sys/net/ipv4/conf/all/send_redirects</span><br><span class="line">    检查icmp_echo_ignore_broadcasts配置(1):cat /proc/sys/net/ipv4/icmp_echo_ignore_broadcasts</span><br><span class="line">    检查ip_forward配置(0):cat /proc/sys/net/ipv4/ip_forward</span><br><span class="line">[加固建议]</span><br><span class="line">    echo &quot;net.ipv4.conf.all.accept_source_route=0&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">    echo &quot;net.ipv4.conf.all.accept_redirects=0&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">    echo &quot;net.ipv4.conf.all.send_redirects=0&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">    echo &quot;net.ipv4.icmp_echo_ignore_broadcasts=1&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">    echo &quot;net.ipv4.ip_forward=0&quot; &gt;&gt; /etc/sysctl.conf</span><br><span class="line">    sysctl -p</span><br></pre></td></tr></table></figure><blockquote><p>使用举例：<br>    检查 Linux 基线：python %s ‘PWD’ –check<br>    配置 Linux 基线：python %s ‘PWD’ –config<br>    不检查防火墙基线检查： python %s ‘PWD’ –check  –skipiptables  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;aqjxpz 工具是基于 python 语言开发的工具，主要针对 Linux 进行进行基线检测。主要针对 Linux 6&amp;#x2F;7 的操作系统做基线检查和配置，其他版本系统可能部分检测无效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockqu</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="安全工具集" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="基线检查工具" scheme="http://suzi007.github.io/tags/%E5%9F%BA%E7%BA%BF%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Windows基线检查工具</title>
    <link href="http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/%E5%9F%BA%E7%BA%BF%E5%B7%A5%E5%85%B7/Windows%E5%9F%BA%E7%BA%BF%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7-PowerShell/"/>
    <id>http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/%E5%9F%BA%E7%BA%BF%E5%B7%A5%E5%85%B7/Windows%E5%9F%BA%E7%BA%BF%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7-PowerShell/</id>
    <published>2024-04-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:30:27.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Baseline-check"><a href="#1-Baseline-check" class="headerlink" title="1 Baseline-check"></a>1 Baseline-check</h1><blockquote><p>Baseline-check 工具是基于 Windows 平台的基线检测工具。<br>使用方式：<br>    使用 powershell 运行 <code>.\windowsBaselineCheck.ps1</code></p></blockquote><blockquote><p>检测内容包括：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">windows 基线检查脚本,检测内容包括：</span><br><span class="line">导出安全策略</span><br><span class="line">账户检查</span><br><span class="line">IP检查</span><br><span class="line">获取所有网络适配器</span><br><span class="line">系统信息检查</span><br><span class="line">读取安全策略配置文件并检测</span><br><span class="line">检查密码最长使用期限策略</span><br><span class="line">检查密码长度最小值策略</span><br><span class="line">检查密码复杂性策略</span><br><span class="line">检查强制密码历史个数</span><br><span class="line">检查账户锁定阀值策略</span><br><span class="line">检查*下次登录必须更改密码策略</span><br><span class="line">检查*强制过期策略</span><br><span class="line">检查管理员名称</span><br><span class="line">检查来宾用户命名</span><br><span class="line">检查Administartor账户停用策略</span><br><span class="line">检查guest账户停用策略 </span><br><span class="line">检查是否开启策略更改审核</span><br><span class="line">检查是否开启登录事件审核</span><br><span class="line">审核对象访问</span><br><span class="line">审核特权使用</span><br><span class="line">审核特权更改</span><br><span class="line">审核账户管理</span><br><span class="line">审核进程跟踪</span><br><span class="line">审核目录服务访问</span><br><span class="line">审核账户登录事件</span><br><span class="line">从网络访问此计算机策略</span><br><span class="line">操作系统远程关机策略安全</span><br><span class="line">操作系统本地关机策略安全 检查可关闭系统的帐户和组</span><br><span class="line">取得文件或其他对象的所有权限策略</span><br><span class="line">检查可远程访问的注册表路径和子路径</span><br><span class="line">检查是否已限制SAM匿名用户连接</span><br><span class="line">检查系统日志文件达到最大大小时的动作的序号</span><br><span class="line">应用日志查看器大小设置  </span><br><span class="line">系统日志查看器大小设置</span><br><span class="line">安全日志查看器大小设置</span><br><span class="line">检查是否已开启Windows防火墙</span><br><span class="line">检查是否已启用SYN攻击保护</span><br><span class="line">检查TCP连接请求阈值</span><br><span class="line">检查取消尝试响应 SYN 请求之前要重新传输 SYN-ACK 的次数</span><br><span class="line">检查处于SYN_RCVD 状态下的 TCP 连接阈值</span><br><span class="line">检查处于SYN_RCVD 状态下,且至少已经进行了一次重新传输的TCP连接阈值</span><br><span class="line">检查是否已启用并正确配置ICMP攻击保护</span><br><span class="line">检查是否已禁用失效网关检测</span><br><span class="line">检查是否已正确配置重传单独数据片段的次数</span><br><span class="line">检查是否已禁用路由发现功能</span><br><span class="line">检查是否已正确配置TCP连接存活时间</span><br><span class="line">检查是否已启用并正确配置TCP碎片攻击保护</span><br><span class="line">检查是否已启用&quot;不显示最后的用户名&quot;策略</span><br><span class="line">检查是否已正确配置&quot;提示用户在密码过期之前进行更改&quot;策略</span><br><span class="line">检查锁定会话时显示用户信息  </span><br><span class="line">检查是否已禁用Windows硬盘默认共享</span><br><span class="line">屏幕自动保护程序</span><br><span class="line">屏幕保护程序启动时间</span><br><span class="line">屏幕恢复时使用密码保护</span><br><span class="line">是否启用NTP服务同步时钟</span><br><span class="line">检查关闭默认共享盘  </span><br><span class="line">禁止全部驱动器自动播放</span><br><span class="line">检查是否正确配置服务器在暂停会话前所需的空闲时间量</span><br><span class="line">检查是否已启用&quot;当登录时间用完时自动注销用户&quot;策略</span><br><span class="line">检查是否已禁用&quot;登录时无须按 Ctrl+Alt+Del&quot;策略</span><br><span class="line">检查是否已禁止Windows自动登录</span><br><span class="line">域环境：检查是否已正确配置&quot;可被缓存保存的登录的个数&quot;策略</span><br></pre></td></tr></table></figure><h1 id="2-Baseline-check"><a href="#2-Baseline-check" class="headerlink" title="2 -Baseline-check"></a>2 -Baseline-check</h1><blockquote><p>Windows 和 linux 基线检查，配套自动化检查脚本。检测完成后会输出结果文件。</p></blockquote><blockquote><p>基线配置文档： 本文规定了 LINUX 操作系统主机应当遵循的操作系统安全性设置标准，本文档旨在指导系统管理人员或安全检查人员进行 LINUX 操作系统的安全合规性检查和配置。 服务器安全基线是指为满足安全规范要求，考虑到信息安全管理的三+四个特性：保密性、完整性、可用性、可审计性、可靠性、抗抵赖性。服务器安全配置必须达到的标准，一般通过检查安全配置参数是否符合安全标准或公司标准来度量。主要包括了账号配置安全、口令配置安全、授权配置、日志配置、IP 通信配置等方面内容，这些安全配置直接反映了系统自身的安全脆弱性。</p></blockquote><blockquote><p>Windows 检测规则如下：</p></blockquote><table><thead><tr><th>第 3 章 账号口令</th><th>6</th></tr></thead><tbody><tr><td>3.1 检查是否已正确配置密码最短使用期限</td><td>6</td></tr><tr><td>3.2 检查是否已正确配置密码长度最小值</td><td>6</td></tr><tr><td>3.3 检查是否已正确配置“强制密码历史”</td><td>7</td></tr><tr><td>3.4 检查是否已正确配置帐户锁定时间</td><td>7</td></tr><tr><td>3.5 检查是否已正确配置帐户锁定阈值</td><td>8</td></tr><tr><td>3.6 检查是否已正确配置“复位帐户锁定计数器”时间</td><td>8</td></tr><tr><td>3.7 检查是否按照权限、责任创建、使用用户账号</td><td>8</td></tr><tr><td>3.8 检查是否已更改管理员帐户名称</td><td>9</td></tr><tr><td>第 4 章 认证授权</td><td>9</td></tr><tr><td>4.1 检查是否已删除可远程访问的注册表路径和子路径</td><td>9</td></tr><tr><td>4.2 检查是否已限制匿名用户连接</td><td>10</td></tr><tr><td>4.3 检查是否已限制可关闭系统的帐户和组</td><td>10</td></tr><tr><td>4.4 检查是否已限制可从远端关闭系统的帐户和组</td><td>11</td></tr><tr><td>4.5 检查是否已限制“取得文件或其它对象的所有权”的帐户和组</td><td>11</td></tr><tr><td>4.6 检查是否已正确配置“允许本地登录”策略</td><td>12</td></tr><tr><td>4.7 检查是否已正确配置“从网络访问此计算机”策略</td><td>12</td></tr><tr><td>4.8 检查是否已删除可匿名访问的共享和命名管道</td><td>13</td></tr><tr><td>第 5 章 日志审计</td><td>13</td></tr><tr><td>5.1 检查是否已正确配置审核(日志记录)策略</td><td>13</td></tr><tr><td>5.2 检查是否已正确配置应用程序日志</td><td>14</td></tr><tr><td>5.3 检查是否已正确配置系统日志</td><td>14</td></tr><tr><td>5.4 检查是否已正确配置安全日志</td><td>15</td></tr><tr><td>第 6 章 协议安全</td><td>15</td></tr><tr><td>6.1 检查是否已修改默认的远程桌面(RDP)服务端口</td><td>15</td></tr><tr><td>6.2 检查是否已启用并正确配置源路由攻击保护</td><td>16</td></tr><tr><td>6.3 检查是否已开启 Windows 防火墙</td><td>16</td></tr><tr><td>6.4 检查是否已启用并正确配置 SYN 攻击保护</td><td>17</td></tr><tr><td>6.5 检查是否已启用并正确配置 ICMP 攻击保护</td><td>18</td></tr><tr><td>6.6 检查是否已禁用失效网关检测</td><td>18</td></tr><tr><td>6.7 检查是否已正确配置重传单独数据片段的次数</td><td>19</td></tr><tr><td>6.8 检查是否已禁用路由发现功能</td><td>19</td></tr><tr><td>6.9 检查是否已正确配置 TCP“连接存活时间”</td><td>20</td></tr><tr><td>6.10 检查是否已启用并正确配置 TCP 碎片攻击保护</td><td>20</td></tr><tr><td>6.11 检查是否已启用 TCP&#x2F;IP 筛选功能</td><td>21</td></tr><tr><td>6.12 检查是否已删除 SNMP 服务的默认 public 团体</td><td>21</td></tr><tr><td>第 7 章 其他配置操作</td><td>22</td></tr><tr><td>7.1 检查是否已安装防病毒软件</td><td>22</td></tr><tr><td>7.2 检查是否已启用并正确配置 Windows 自动更新</td><td>22</td></tr><tr><td>7.3 检查是否已启用“不显示最后的用户名”策略</td><td>23</td></tr><tr><td>7.4 检查是否已正确配置“提示用户在密码过期之前进行更改”策略</td><td>23</td></tr><tr><td>7.5 检查是否已正确配置“锁定会话时显示用户信息”策略</td><td>24</td></tr><tr><td>7.6 检查是否已禁用 Windows 硬盘默认共享</td><td>24</td></tr><tr><td>7.7 检查是否已启用并正确配置屏幕保护程序</td><td>25</td></tr><tr><td>7.8 检查是否已启用并正确配置 Windows 网络时间同步服务(NTP)</td><td>25</td></tr><tr><td>7.9 检查是否已关闭 Windows 自动播放</td><td>26</td></tr><tr><td>7.10 检查是否已关闭不必要的服务-DHCP Client</td><td>26</td></tr><tr><td>7.11 检查系统是否已安装最新补丁包和补丁</td><td>26</td></tr><tr><td>7.12 检查所有磁盘分区的文件系统格式</td><td>27</td></tr><tr><td>7.13 检查是否已正确配置服务器在暂停会话前所需的空闲时间量</td><td>27</td></tr><tr><td>7.14 检查是否已启用“当登录时间用完时自动注销用户”策略</td><td>28</td></tr><tr><td>7.15 域环境：检查是否已启用“需要域控制器身份验证以解锁工作站”策略</td><td>28</td></tr><tr><td>7.16 检查是否已禁用“登录时无须按 Ctrl+Alt+Del”策略</td><td>29</td></tr><tr><td>7.17 域环境：检查是否已正确配置“可被缓存保存的登录的个数”策略</td><td>29</td></tr><tr><td>7.18 域环境：检查是否已正确配置域环境下安全通道数据的安全设置</td><td>30</td></tr><tr><td>7.19 域环境：检查是否已启用“域环境下需要强会话密钥”策略</td><td>30</td></tr><tr><td>7.20 检查共享文件夹的权限设置是否安全</td><td>31</td></tr><tr><td>7.21 检查是否已启用 Windows 数据执行保护(DEP)</td><td>31</td></tr><tr><td>7.22 检查是否已创建多个磁盘分区</td><td>31</td></tr><tr><td>7.23 检查是否已禁止 Windows 自动登录</td><td>32</td></tr><tr><td>7.24 检查是否已关闭不必要的服务-Simple TCP&#x2F;IP Services</td><td>32</td></tr><tr><td>7.25 检查是否已关闭不必要的服务-Simple Mail Transport Protocol (SMTP)</td><td>33</td></tr><tr><td>7.26 检查是否已关闭不必要的服务-Windows Internet Name Service (WINS)</td><td>33</td></tr><tr><td>7.27 检查是否已关闭不必要的服务-DHCP Server</td><td>34</td></tr><tr><td>7.28 检查是否已关闭不必要的服务-Remote Access Connection Manager</td><td>34</td></tr><tr><td>7.29 检查是否已关闭不必要的服务-Message Queuing</td><td>34</td></tr></tbody></table><blockquote><p>Linux 检测规则</p></blockquote><table><thead><tr><th>第 2 章</th><th>账号口令</th><th>3</th></tr></thead><tbody><tr><td>2.1</td><td>检查是否已设置口令生存周期</td><td>3</td></tr><tr><td>2.2</td><td>检查口令最小长度</td><td>4</td></tr><tr><td>2.3</td><td>检查是否设置口令过期警告天数</td><td>4</td></tr><tr><td>2.4</td><td>检查设备密码复杂度策略</td><td>5</td></tr><tr><td>2.5</td><td>检查是否存在空口令账号</td><td>5</td></tr><tr><td>2.6</td><td>检查是否设置除 root 之外 UID 为 0 的用户</td><td>6</td></tr><tr><td>第 3 章</td><td>认证授权</td><td>6</td></tr><tr><td>3.1</td><td>检查用户 umask 设置</td><td>6</td></tr><tr><td>3.2</td><td>检查重要目录或文件权限设置</td><td>7</td></tr><tr><td>3.3</td><td>检查重要文件属性设置-需重启</td><td>9</td></tr><tr><td>3.4</td><td>检查用户目录缺省访问权限设置</td><td>11</td></tr><tr><td>3.5</td><td>检查是否设置 ssh 登录前警告 Banner</td><td>11</td></tr><tr><td>第 4 章</td><td>日志审计</td><td>12</td></tr><tr><td>4.1</td><td>检查是否配置远程日志功能</td><td>12</td></tr><tr><td>4.2</td><td>检查安全事件日志配置</td><td>13</td></tr><tr><td>4.3</td><td>检查日志文件是否非全局可写</td><td>14</td></tr><tr><td>4.4</td><td>检查是否对登录进行日志记录</td><td>15</td></tr><tr><td>4.5</td><td>检查是否配置 su 命令使用情况记录</td><td>16</td></tr><tr><td>第 5 章</td><td>协议安全</td><td>17</td></tr><tr><td>5.1</td><td>检查系统 openssh 安全配置</td><td>17</td></tr><tr><td>5.2</td><td>检查是否已修改 snmp 默认团体字</td><td>17</td></tr><tr><td>5.3</td><td>检查使用 ip 协议远程维护的设备是否配置 ssh 协议，禁用 telnet 协议</td><td>18</td></tr><tr><td>5.4</td><td>检查是否禁止 root 用户登录 ftp</td><td>18</td></tr><tr><td>5.5</td><td>检查是否禁止匿名用户登录 FTP</td><td>19</td></tr><tr><td>第 6 章</td><td>其他配置操作</td><td>20</td></tr><tr><td>6.1</td><td>检查是否设置命令行界面超时退出-需重启</td><td>20</td></tr><tr><td>6.2</td><td>检查是否设置系统引导管理器密码</td><td>20</td></tr><tr><td>6.3</td><td>检查系统 core dump 设置</td><td>21</td></tr><tr><td>6.4</td><td>检查历史命令设置</td><td>21</td></tr><tr><td>6.5</td><td>检查是否使用 PAM 认证模块禁止 wheel 组之外的用户 su 为 root</td><td>22</td></tr><tr><td>6.6</td><td>检查是否对系统账户进行登录限制</td><td>22</td></tr><tr><td>6.7</td><td>检查密码重复使用次数限制</td><td>23</td></tr><tr><td>6.8</td><td>检查用户认证失败次数限制</td><td>24</td></tr><tr><td>6.9</td><td>检查是否关闭绑定多 ip 功能</td><td>25</td></tr><tr><td>6.10</td><td>检查是否限制远程登录 ip 范围</td><td>25</td></tr><tr><td>6.11</td><td>检查别名文件&#x2F;etc&#x2F;aliases(或&#x2F;etc&#x2F;mail&#x2F;aliases)配置</td><td>26</td></tr><tr><td>6.12</td><td>检查拥有 suid 和 sgid 权限的文件</td><td>28</td></tr><tr><td>6.13</td><td>检查是否配置定时自动屏幕锁定（适用于具备图形界面的设备）</td><td>28</td></tr><tr><td>6.14</td><td>检查系统内核参数配置</td><td>30</td></tr><tr><td>6.15</td><td>检查是否按组进行账号管理</td><td>31</td></tr><tr><td>6.16</td><td>检查是否按用户分配账号</td><td>32</td></tr><tr><td>6.17</td><td>检查 root 用户的 path 环境变量</td><td>32</td></tr><tr><td>6.18</td><td>检查系统是否禁用 ctrl+alt+del 组合键-需重启</td><td>33</td></tr><tr><td>6.19</td><td>检查是否关闭系统信任机制</td><td>33</td></tr><tr><td>6.20</td><td>检查系统磁盘分区使用率</td><td>34</td></tr><tr><td>6.21</td><td>检查是否删除了潜在危险文件</td><td>34</td></tr><tr><td>6.22</td><td>检查是否删除与设备运行，维护等工作无关的账号</td><td>35</td></tr><tr><td>6.23</td><td>检查是否配置用户所需最小权限</td><td>36</td></tr><tr><td>6.24</td><td>检查是否关闭数据包转发功能（适用于不做路由功能的系统）-对于集群系统或者需要数据包转发的系统不做该配置</td><td>37</td></tr><tr><td>6.25</td><td>检查是否禁用不必要的系统服务</td><td>37</td></tr><tr><td>6.26</td><td>检查是否使用 NTP（网络时间协议）保持时间同步</td><td>38</td></tr><tr><td>6.27</td><td>检查 NFS（网络文件系统）服务设置</td><td>39</td></tr><tr><td>6.28</td><td>检查是否安装 OS 补丁</td><td>39</td></tr><tr><td>6.29</td><td>检查是否设置 ssh 成功登陆后 Banner</td><td>40</td></tr><tr><td>6.30</td><td>检查 FTP 用户上传的文件所具有的权限</td><td>40</td></tr><tr><td>6.31</td><td>检查 FTP Banner 设置</td><td>41</td></tr><tr><td>6.32</td><td>检查&#x2F;usr&#x2F;bin&#x2F;目录下可执行文件的拥有者属性</td><td>42</td></tr><tr><td>6.33</td><td>检查 telnet Banner 设置</td><td>42</td></tr><tr><td>6.34</td><td>检查是否限制 FTP 用户登录后能访问的目录</td><td>43</td></tr><tr><td>6.35</td><td>检查是否关闭不必要的服务和端口-需重启</td><td>44</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Baseline-check&quot;&gt;&lt;a href=&quot;#1-Baseline-check&quot; class=&quot;headerlink&quot; title=&quot;1 Baseline-check&quot;&gt;&lt;/a&gt;1 Baseline-check&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;B</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="安全工具集" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="基线检查工具" scheme="http://suzi007.github.io/tags/%E5%9F%BA%E7%BA%BF%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>数据库基线检查工具</title>
    <link href="http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/%E5%9F%BA%E7%BA%BF%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93Mysql%E5%9F%BA%E7%BA%BF%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/"/>
    <id>http://suzi007.github.io/2024/04/17/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/%E5%9F%BA%E7%BA%BF%E5%B7%A5%E5%85%B7/%E6%95%B0%E6%8D%AE%E5%BA%93Mysql%E5%9F%BA%E7%BA%BF%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/</id>
    <published>2024-04-17T07:11:11.000Z</published>
    <updated>2025-03-29T16:30:27.750Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>DB_BASELINE 主要用于数据库的配置项的基线检查。<br>该文档主要描述了 DB_BASELINE 的使用方法以及检测脚本的编写规范，编写规范检测脚本适用于后期导入 SYSLOG，SOC 等<br>支持的数据库：MySQL</p></blockquote><blockquote><p>检测内容包括：</p></blockquote><ul><li><p>账号权限</p><ul><li>检查运行数据库的账号，</li><li>数据库里面各个权限账号</li><li>检查方向：是否有过多的不必要的权限   <ul><li>用专有的低权限账号去启动数据库，而不是用 root</li><li>数据库账号不要空密码连接</li><li>删除或者修改默认账号</li><li>只有 DBA 拥有所有权限，其余各个数据库有专门的对应的数据库的账号</li><li>数据库的账号要限制 IP 连接</li><li>…</li></ul></li></ul></li><li><p>网络连接</p><ul><li>端口</li><li>连接类型</li><li>检查方向：主要用于检查数据库的端口，对外的开放的程度，连接的安全性等等 <ul><li>端口改掉默认端口</li><li>如果提供对外访问 那么网络传输使用 SSL 或者其他加密的协议</li></ul></li></ul></li><li><p>文件安全</p><ul><li>配置文件</li><li>日志文件</li><li>审计文件</li><li>备份文件</li><li>检查方向：主要检查文件权限是否配置准确   <ul><li>配置文件，日志文件等应只有数据库账号可以访问</li><li>限制数据库账号访问其他目录或者对其他目录有写的权限</li><li>…</li></ul></li></ul></li><li><p>数据库配置的属性</p><ul><li>配置文件 </li><li>可以执行的函数</li><li>检查方向：潜在隐患的配置属性<ul><li>危险函数禁止执行<ul><li>执行系统命令</li><li>读取文件</li><li>写入文件</li><li>导入导出</li><li>…</li></ul></li><li>安全配置是否开启<ul><li>日志文件是否开启</li><li>审计文件是否开启</li><li>错误日志是否开启</li><li>密码复杂度</li><li>过期账号处理</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;DB_BASELINE 主要用于数据库的配置项的基线检查。&lt;br&gt;该文档主要描述了 DB_BASELINE 的使用方法以及检测脚本的编写规范，编写规范检测脚本适用于后期导入 SYSLOG，SOC 等&lt;br&gt;支持的数据库：MySQL&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="网络安全" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    <category term="安全工具集" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    
    
    <category term="网络安全工具" scheme="http://suzi007.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7/"/>
    
    <category term="基线检查工具" scheme="http://suzi007.github.io/tags/%E5%9F%BA%E7%BA%BF%E6%A3%80%E6%9F%A5%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>爬虫常用库</title>
    <link href="http://suzi007.github.io/2024/04/14/%E7%88%AC%E8%99%AB%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    <id>http://suzi007.github.io/2024/04/14/%E7%88%AC%E8%99%AB%E5%B8%B8%E7%94%A8%E5%BA%93/</id>
    <published>2024-04-14T13:43:02.000Z</published>
    <updated>2025-01-03T02:37:09.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-通用库"><a href="#1-通用库" class="headerlink" title="1 通用库"></a>1 通用库</h1><p>1.urllib -网络库(stdlib)。<br>2.requests -网络库。<br>3.grab – 网络库（基于pycurl）。<br>4.pycurl – 网络库（绑定libcurl）。<br>5.urllib3 – Python HTTP库，安全连接池、支持文件post、可用性高。<br>6.httplib2 – 网络库。<br>7.RoboBrowser – 一个简单的、极具Python风格的Python库，无需独立的浏览器即可浏览网页。<br>8.MechanicalSoup -一个与网站自动交互Python库。<br>9.mechanize -有状态、可编程的Web浏览库。<br>10.socket – 底层网络接口(stdlib)。<br>11.Unirest for Python – Unirest是一套可用于多种语言的轻量级的HTTP库。<br>12.hyper – Python的HTTP&#x2F;2客户端。<br>13.PySocks – SocksiPy 更新并积极维护的版本，包括错误修复和一些其他的特征。作为 socket 模块的直接替换。</p><h1 id="2-网络爬虫框架"><a href="#2-网络爬虫框架" class="headerlink" title="2 网络爬虫框架"></a>2 网络爬虫框架</h1><p>grab – 网络爬虫框架（基于 pycurl&#x2F;multicur）。<br>scrapy – 网络爬虫框架（基于 twisted），不支持 Python3。<br>pyspider – 一个强大的爬虫系统。<br>cola – 一个分布式爬虫框架。<br>portia – 基于 Scrapy 的可视化爬虫。<br>restkit – Python 的 HTTP 资源工具包。它可以让你轻松地访问 HTTP 资源，并围绕它建立的对象。<br>demiurge – 基于PyQuery的爬虫微框架。</p><h1 id="3-HTML-XML-解析器"><a href="#3-HTML-XML-解析器" class="headerlink" title="3 HTML&#x2F;XML 解析器"></a>3 HTML&#x2F;XML 解析器</h1><h2 id="3-1-通用"><a href="#3-1-通用" class="headerlink" title="3.1 通用"></a>3.1 通用</h2><p>lxml – C 语言编写高效 HTML&#x2F; XML 处理库。支持 XPath。<br>cssselect – 解析 DOM 树和 CSS 选择器。<br>pyquery – 解析 DOM 树和 jQuery 选择器。<br>BeautifulSoup – 低效 HTML&#x2F; XML 处理库，纯 Python 实现。<br>html5lib – 根据 WHATWG 规范生成 HTML&#x2F; XML 文档的 DOM。该规范被用在现在所有的浏览器上。<br>feedparser – 解析 RSS&#x2F;ATOM feeds。<br>MarkupSafe – 为 XML&#x2F;HTML&#x2F;XHTML 提供了安全转义的字符串。<br>xmltodict – 一个可以让你在处理 XML 时感觉像在处理 JSON 一样的 Python 模块。<br>xhtml2pdf – 将 HTML&#x2F;CSS 转换为 PDF。<br>untangle – 轻松实现将XML文件转换为Python对象。</p><h2 id="3-2-清理"><a href="#3-2-清理" class="headerlink" title="3.2 清理"></a>3.2 清理</h2><p>Bleach – 清理 HTML（需要 html5lib）。<br>sanitize – 为混乱的数据世界带来清明。</p><h1 id="4-文本处理"><a href="#4-文本处理" class="headerlink" title="4 文本处理"></a>4 文本处理</h1><p>difflib – （Python 标准库）帮助进行差异化比较。<br>Levenshtein – 快速计算Levenshtein距离和字符串相似度。<br>fuzzywuzzy – 模糊字符串匹配。<br>esmre – 正则表达式加速器。<br>ftfy – 自动整理 Unicode 文本，减少碎片化。</p><h1 id="5-自然语言处理"><a href="#5-自然语言处理" class="headerlink" title="5 自然语言处理"></a>5 自然语言处理</h1><p>NLTK -编写 Python 程序来处理人类语言数据的最好平台。<br>Pattern – Python 的网络挖掘模块。他有自然语言处理工具，机器学习以及其它。<br>TextBlob – 为深入自然语言处理任务提供了一致的 API。是基于 NLTK 以及 Pattern 的巨人之肩上发展的。<br>jieba – 中文分词工具。<br>SnowNLP – 中文文本处理库。<br>loso – 另一个中文分词库。</p><h1 id="6-浏览器自动化与仿真"><a href="#6-浏览器自动化与仿真" class="headerlink" title="6 浏览器自动化与仿真"></a>6 浏览器自动化与仿真</h1><p>selenium – 自动化真正的浏览器（Chrome 浏览器，火狐浏览器，Opera 浏览器，IE 浏览器）。<br>Ghost.py – 对 PyQt 的 webkit 的封装（需要 PyQT）。<br>Spynner – 对 PyQt 的 webkit 的封装（需要 PyQT）。<br>Splinter – 通用 API 浏览器模拟器（selenium web 驱动，Django 客户端，Zope）。</p><h1 id="7-多重处理"><a href="#7-多重处理" class="headerlink" title="7 多重处理"></a>7 多重处理</h1><p>threading – Python 标准库的线程运行。对于 I&#x2F;O 密集型任务很有效。对于 CPU 绑定的任务没用，因为 python GIL。<br>multiprocessing – 标准的 Python 库运行多进程。<br>celery – 基于分布式消息传递的异步任务队列&#x2F;作业队列。<br>concurrent-futures – concurrent-futures 模块为调用异步执行提供了一个高层次的接口。</p><h1 id="8-异步网络编程"><a href="#8-异步网络编程" class="headerlink" title="8 异步网络编程"></a>8 异步网络编程</h1><p>asyncio – （在 Python 3.4 +版本以上的 Python 标准库）异步 I&#x2F;O，时间循环，协同程序和任务。<br>Twisted – 基于事件驱动的网络引擎框架。<br>Tornado – 一个网络框架和异步网络库。<br>pulsar – Python 事件驱动的并发框架。<br>diesel – Python 的基于绿色事件的 I&#x2F;O 框架。<br>gevent – 一个使用 greenlet 的基于协程的 Python 网络库。<br>eventlet – 有 WSGI 支持的异步框架。<br>Tomorrow – 异步代码的奇妙的修饰语法。</p><h1 id="9-队列"><a href="#9-队列" class="headerlink" title="9 队列"></a>9 队列</h1><p>celery – 基于分布式消息传递的异步任务队列&#x2F;作业队列。<br>huey – 小型多线程任务队列。<br>mrq – Mr. Queue – 使用 redis &amp; Gevent 的 Python 分布式工作任务队列。<br>RQ – 基于 Redis 的轻量级任务队列管理器。<br>simpleq – 一个简单的，可无限扩展，基于 Amazon SQS 的队列。<br>python-gearman – Gearman 的 Python API。</p><h1 id="10-云计算"><a href="#10-云计算" class="headerlink" title="10 云计算"></a>10 云计算</h1><p>picloud – 云端执行 Python 代码。<br>dominoup.com – 云端执行 R，Python 和 matlab 代码</p><h1 id="11-网页内容提取"><a href="#11-网页内容提取" class="headerlink" title="11 网页内容提取"></a>11 网页内容提取</h1><p>HTML 页面的文本和元数据<br>newspaper – 用 Python 进行新闻提取、文章提取和内容策展。<br>html2text – 将 HTML 转为 Markdown 格式文本。<br>python-goose – HTML 内容&#x2F;文章提取器。<br>lassie – 人性化的网页内容检索工具</p><h1 id="12-WebSocket"><a href="#12-WebSocket" class="headerlink" title="12 WebSocket"></a>12 WebSocket</h1><p>Crossbar – 开源的应用消息传递路由器（Python 实现的用于 Autobahn 的 WebSocket 和 WAMP）。<br>AutobahnPython – 提供了 WebSocket 协议和 WAMP 协议的 Python 实现并且开源。<br>WebSocket-for-Python – Python 2和3以及 PyPy 的 WebSocket 客户端和服务器库。</p><h1 id="13-DNS-解析"><a href="#13-DNS-解析" class="headerlink" title="13 DNS 解析"></a>13 DNS 解析</h1><p>dnsyo – 在全球超过1500个的 DNS 服务器上检查你的 DNS。<br>pycares – c-ares 的接口。c-ares 是进行 DNS 请求和异步名称决议的 C 语言库。</p><h1 id="14-计算机视觉"><a href="#14-计算机视觉" class="headerlink" title="14 计算机视觉"></a>14 计算机视觉</h1><p>OpenCV – 开源计算机视觉库。<br>SimpleCV – 用于照相机、图像处理、特征提取、格式转换的简介，可读性强的接口（基于 OpenCV）。<br>mahotas – 快速计算机图像处理算法（完全使用 C++ 实现），完全基于 numpy 的数组作为它的数据类型。</p><h1 id="15-Web-开发"><a href="#15-Web-开发" class="headerlink" title="15 Web 开发"></a>15 Web 开发</h1><h2 id="15-1-Django"><a href="#15-1-Django" class="headerlink" title="15.1 Django"></a>15.1 Django</h2><p>Django 是一个开源的 Web 应用框架，由 Python 写成，支持许多数据库引擎，可以让 Web 开发变得迅速和可扩展，并会不断的版本更新以匹配 Python 最新版本，如果是新手程序员，可以从这个框架入手。</p><h2 id="15-2-Flask"><a href="#15-2-Flask" class="headerlink" title="15.2 Flask"></a>15.2 Flask</h2><p>Flask 是一个轻量级的 Web 应用框架, 使用 Python 编写。基于 WerkzeugWSGI 工具箱和 Jinja2模板引擎。使用 BSD 授权。<br>Flask 也被称为 “microframework” ，因为它使用简单的核心，用 extension 增加其他功能。Flask 没有默认使用的数据库、窗体验证工具。然而，Flask 保留了扩增的弹性，可以用 Flask-extension 加入这些功 能：ORM、窗体验证工具、文件上传、各种开放式身份验证技术。</p><h2 id="15-3-Web2py"><a href="#15-3-Web2py" class="headerlink" title="15.3 Web2py"></a>15.3 Web2py</h2><p>Web2py 是一个用 Python 语言编写的免费的开源 Web 框架，旨在敏捷快速的开发 Web 应用，具有快速、可扩展、安全以及可移植的数据库驱动的应用，遵循 LGPLv3开源协议。</p><p>Web2py 提供一站式的解决方案，整个开发过程都可以在浏览器上进行，提供了 Web 版的在线开发，HTML 模版编写，静态文件的上传，数据库的编写的功能。其它的还有日志功能，以及一个自动化的 admin 接口。</p><h2 id="15-4-Tornado"><a href="#15-4-Tornado" class="headerlink" title="15.4 Tornado"></a>15.4 Tornado</h2><p>ornado 即是一个 Web server（对此本文不作详述），同时又是一个类 web.py 的 micro-framework，作为框架 Tornado 的思想主要来源于 Web.py，大家在 Web.py 的网站首页也可以看到 Tornado 的大佬 Bret Taylor 的这么一段话（他这里说的 FriendFeed 用的框架跟 Tornado 可以看作是一个东西）</p><h2 id="15-5-CherryPy"><a href="#15-5-CherryPy" class="headerlink" title="15.5 CherryPy"></a>15.5 CherryPy</h2><p>CherryPy是一种用于Python的、简单而非常有用的Web框架，其主要作用是以尽可能少的操作将Web服务器与Python代码连接，其功能包括内置的分析功能、灵活的插件系统以及一次运行多个HTTP服务器的功能，可与运行在最新版本的Python、Jython、Android上。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-通用库&quot;&gt;&lt;a href=&quot;#1-通用库&quot; class=&quot;headerlink&quot; title=&quot;1 通用库&quot;&gt;&lt;/a&gt;1 通用库&lt;/h1&gt;&lt;p&gt;1.urllib -网络库(stdlib)。&lt;br&gt;2.requests -网络库。&lt;br&gt;3.grab – 网络库</summary>
      
    
    
    
    <category term="网络爬虫" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
    <category term="爬虫工具" scheme="http://suzi007.github.io/categories/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="爬虫程序设计" scheme="http://suzi007.github.io/tags/%E7%88%AC%E8%99%AB%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="爬虫常用库" scheme="http://suzi007.github.io/tags/%E7%88%AC%E8%99%AB%E5%B8%B8%E7%94%A8%E5%BA%93/"/>
    
  </entry>
  
</feed>
